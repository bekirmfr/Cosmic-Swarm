<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Cosmic Swarm: Awakening - Enhanced Edition</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <h1>COSMIC SWARM: AWAKENING</h1>

    <div class="game-container">
        <canvas id="gameCanvas" width="400" height="400"></canvas>

        <div id="ui">
            <div class="planet-info">
                <div class="planet-name">
                    <span class="planet-icon" id="planetIcon">ü™ê</span>
                    <div>
                        <span id="planetName">Alpha-427</span>
                        <span class="level-indicator" id="playerLevel">1</span>
                    </div>
                </div>
                <div>Type: <span id="planetType">Mineral-Rich</span></div>
                <div>Mission: <span id="missionCounter">1</span></div>
                <div id="weatherDisplay" style="margin-top: 0.25rem; font-size: 0.8rem;"></div>
            </div>

            <div class="xp-container">
                <div id="xpBar" class="xp-bar" style="width: 0%;"></div>
            </div>
            <div class="xp-info">
                <span>XP: <span id="currentXP">0</span>/<span id="requiredXP">100</span></span>
                <span>Next Level: <span id="nextLevel">2</span></span>
            </div>

            <div class="energy-container">
                <div id="energyBar" class="energy-bar" style="width: 100%;"></div>
            </div>
            <div style="text-align: center; margin-bottom: 0.5rem;">
                <div class="resource-icon" style="display: inline-block; margin-right: 0.5rem;">‚ö°</div>
                <span id="energy">100</span><span>/<span id="maxEnergy">100</span></span>
            </div>

            <div class="resources">
                <div class="resource">
                    <div class="resource-icon">üî∑</div>
                    <div>Minerals: <span id="minerals">0</span></div>
                </div>
                <div class="resource">
                    <div class="resource-icon">üíé</div>
                    <div>Crystals: <span id="crystals">0</span></div>
                </div>
                <div class="resource">
                    <div class="resource-icon">üß™</div>
                    <div>Exotic: <span id="exotic">0</span></div>
                </div>
                <div class="resource">
                    <div class="resource-icon">‚è±Ô∏è</div>
                    <div><span id="actionTimer">Ready</span></div>
                </div>
            </div>

            <div id="actionProgressContainer" class="action-progress-container" style="display: none;">
                <div id="actionProgressBar" class="action-progress-bar" style="width: 0%;"></div>
            </div>

            <div class="status-effects" id="statusEffects"></div>
            <div class="upgrades" id="upgrades"></div>

            <div class="control-panel">
                <button id="scanBtn" onclick="scanTile()">Scan Tile (‚ö°3)</button>
                <button id="buildBaseBtn" onclick="buildBase()">Build Base (üî∑3)</button>
                <button id="harvestBtn" onclick="harvestResource()">Harvest (‚ö°5)</button>
                <button id="constructShipBtn" onclick="constructShip()">Launch Ship (üî∑5, üíé2)</button>
            </div>

            <div class="movement-panel">
                <button disabled></button>
                <button id="moveUpBtn" onclick="moveRobot('up')">‚Üë</button>
                <button disabled></button>
                <button id="moveLeftBtn" onclick="moveRobot('left')">‚Üê</button>
                <button disabled></button>
                <button id="moveRightBtn" onclick="moveRobot('right')">‚Üí</button>
                <button disabled></button>
                <button id="moveDownBtn" onclick="moveRobot('down')">‚Üì</button>
                <button disabled></button>
            </div>

            <div class="drone-section">
                <div class="drone-info">
                    <div class="drone-icon" id="droneIcon">ü§ñ</div>
                    <div>
                        <div id="droneName">Drone MK-I</div>
                        <div class="drone-status" id="droneStatus">Ready</div>
                    </div>
                </div>
                <div class="drone-controls">
                    <button class="drone-button" id="droneDeployBtn" onclick="deployDrone()">Deploy</button>
                    <button class="drone-button" id="droneListBtn" onclick="toggleDronesMenu()">Drones</button>
                </div>
            </div>

            <div class="objectives">
                <div><strong>PRIMARY MISSION:</strong></div>
                <div id="primaryObjective">Build base and launch ship</div>
                <div id="objectiveStatus">In Progress - 0%</div>
                <progress id="objectiveProgress" value="0" max="100" style="width: 100%; margin-top: 0.5rem;"></progress>
                <div id="specialMission" class="special-mission" style="display: none;">
                    <div id="specialMissionText"></div>
                    <div class="special-mission-progress">
                        <div id="specialMissionBar" class="special-mission-bar" style="width: 0%;"></div>
                    </div>
                </div>
            </div>

            <div class="tech-tree-container">
                <div class="tech-tree-title">
                    <div><strong>TECH TREE:</strong></div>
                    <div>Points: <span id="techPoints">0</span></div>
                </div>
                <div class="tech-nodes" id="techNodes">
                    <!-- Tech nodes will be inserted here -->
                </div>
            </div>

            <div class="side-missions" id="sideMissions">
                <div><strong>SIDE MISSIONS:</strong></div>
                <div id="noMissions">No active side missions</div>
            </div>

            <div class="mission-log" id="missionLog">
                <div class="log-entry">System initialized. Robot deployed to planet surface.</div>
            </div>

            <div class="score-display">
                <div>Total Score: <span id="totalScore">0</span></div>
            </div>

            <div class="progress-section">
                <div>Planets: <span id="planetsExplored">0</span></div>
                <div>Resources: <span id="totalResources">0</span></div>
            </div>

            <div class="sound-controls">
                <button id="musicToggle" class="sound-button">üéµ</button>
                <button id="sfxToggle" class="sound-button">üîä</button>
            </div>
        </div>
    </div>

    <div class="settings-panel">
        <button id="settingsBtn" class="settings-button">‚öôÔ∏è</button>
        <button id="shareBtn" class="settings-button">üì§</button>
        <button id="achievementsBtn" class="settings-button">üèÜ</button>
    </div>

    <div id="settings-menu">
        <div class="settings-option">
            <label for="difficultySelect">Difficulty:</label>
            <select id="difficultySelect">
                <option value="easy">Easy</option>
                <option value="normal" selected>Normal</option>
                <option value="hard">Hard</option>
                <option value="extreme">Extreme</option>
            </select>
        </div>
        <div class="settings-option">
            <label for="gridSizeSelect">Grid Size:</label>
            <select id="gridSizeSelect">
                <option value="5">5x5</option>
                <option value="6" selected>6x6</option>
                <option value="7">7x7</option>
                <option value="8">8x8</option>
                <option value="10">10x10</option>
            </select>
        </div>
        <div class="settings-option">
            <label for="visualEffectsSelect">Visual Effects:</label>
            <select id="visualEffectsSelect">
                <option value="high">High</option>
                <option value="medium" selected>Medium</option>
                <option value="low">Low</option>
            </select>
        </div>
        <div class="settings-option">
            <label for="showFpsCheckbox">Show FPS:</label>
            <input type="checkbox" id="showFpsCheckbox">
        </div>
        <div class="settings-option">
            <button id="resetProgressBtn">Reset Progress</button>
        </div>
        <div class="settings-option">
            <button id="closeSettingsBtn">Close</button>
        </div>
    </div>

    <div id="social-menu">
        <div class="settings-option">
            <button id="screenshotBtn">Take Screenshot</button>
        </div>
        <div class="settings-option">
            <button id="shareSeedBtn">Share Planet Seed</button>
        </div>
        <div class="settings-option">
            <button id="shareScoreBtn">Share Score</button>
        </div>
        <div class="settings-option">
            <button id="exportSaveBtn">Export Save Data</button>
        </div>
        <div class="settings-option">
            <button id="importSaveBtn">Import Save Data</button>
        </div>
        <div class="settings-option">
            <button id="closeSocialBtn">Close</button>
        </div>
    </div>

    <div id="drones-menu">
        <div><strong>AVAILABLE DRONES</strong></div>
        <div class="drone-list" id="dronesList">
            <!-- Drone list items will be inserted here -->
        </div>
        <div class="settings-option" style="margin-top: 1rem;">
            <button id="closeDronesBtn">Close</button>
        </div>
    </div>

    <div id="start-game-overlay" style="display: flex;">
        <div class="modal fade-in">
            <h2>COSMIC SWARM: AWAKENING</h2>
            <p>You are part of humanity's greatest endeavor: the Autonomous Intelligence Swarm. Deployed to explore the far reaches of space, your mission is to establish bases on distant worlds and continue the expansion of our knowledge.</p>
            <p>Land on unexplored planets, harvest resources, build bases, and launch new vessels to continue the chain of exploration. The fate of human knowledge rests on your robotic shoulders.</p>
            <p><strong>Your first planet awaits, explorer. Are you ready?</strong></p>
            <button class="big-btn" onclick="window.startGame()">BEGIN MISSION</button>
        </div>
    </div>

    <div id="game-over-overlay" style="display: none;">
        <div class="modal fade-in">
            <h2>MISSION FAILED</h2>
            <p>Your robot has run out of energy and can no longer function. The mission to expand humanity's reach across the stars has come to a halt.</p>
            <p>But the cosmos is vast, and our determination is endless.</p>
            <div class="stats">
                <div>Planet: <span id="gameOverPlanet">-</span></div>
                <div>Resources: <span id="gameOverResources">0</span></div>
                <div>Score: <span id="gameOverScore">0</span></div>
            </div>
            <button class="big-btn" onclick="retryMission()">RETRY MISSION</button>
        </div>
    </div>

    <div id="game-overlay" style="display: none;">
        <div class="modal fade-in">
            <h2 id="modalTitle">Mission Complete!</h2>
            <p id="modalContent">You have successfully constructed a ship and launched to the next planet.</p>
            <div class="stats">
                <div>Mission: <span id="statMission">0</span></div>
                <div>Resources: <span id="statResources">0</span></div>
                <div>Efficiency: <span id="statEfficiency">0%</span></div>
                <div>Score: <span id="statScore">0</span></div>
                <div>XP Gained: <span id="statXP">0</span></div>
            </div>
            <div class="achievements" id="missionAchievements"></div>
            <button class="big-btn" onclick="startNextMission()">NEXT MISSION</button>
        </div>
    </div>

    <div id="special-event-overlay" style="display: none;">
        <div class="modal fade-in">
            <h2 id="specialEventTitle">Discovery!</h2>
            <p id="specialEventContent">You have discovered something unusual...</p>
            <div id="specialEventChoices"></div>
            <button class="big-btn" id="specialEventCloseBtn">CONTINUE</button>
        </div>
    </div>

    <div id="side-mission-overlay" style="display: none;">
        <div class="modal fade-in">
            <h2 id="sideMissionTitle">New Mission</h2>
            <p id="sideMissionContent">A new opportunity has been detected...</p>
            <div class="stats">
                <div>Reward: <span id="sideMissionReward">-</span></div>
            </div>
            <button class="big-btn" id="acceptMissionBtn">ACCEPT MISSION</button>
            <button id="declineMissionBtn">DECLINE</button>
        </div>
    </div>

    <div id="achievement-overlay" style="display: none;">
        <div class="modal fade-in">
            <h2>Achievement Unlocked!</h2>
            <p id="achievementName">First Steps</p>
            <p id="achievementDescription">You took your first steps on an alien world.</p>
            <div class="stats">
                <div>Bonus: <span id="achievementBonus">+0</span> points</div>
            </div>
            <button class="big-btn" id="achievementCloseBtn">CONTINUE</button>
        </div>
    </div>

    <div id="tech-unlock-overlay" style="display: none;">
        <div class="modal fade-in">
            <h2>Technology Unlocked!</h2>
            <p id="techUnlockName">Energy Efficiency</p>
            <p id="techUnlockDescription">You've developed more efficient energy systems.</p>
            <div id="techUnlockEffects" class="stats">
                <div>Effect: <span id="techUnlockEffect">-</span></div>
            </div>
            <button class="big-btn" id="techUnlockCloseBtn">CONTINUE</button>
        </div>
    </div>

    <div id="relic-discovery-overlay" style="display: none;">
        <div class="modal fade-in">
            <h2>Ancient Relic Discovered!</h2>
            <p id="relicName">Crystal Resonator</p>
            <p id="relicDescription">A mysterious device that amplifies crystal energy.</p>
            <div class="stats">
                <div>Effect: <span id="relicEffect">-</span></div>
            </div>
            <button class="big-btn" id="relicCloseBtn">CONTINUE</button>
        </div>
    </div>

    <div id="drone-selection-overlay" style="display: none;">
        <div class="modal fade-in">
            <h2>Deploy Drone</h2>
            <p id="droneSelectionDescription">Select a drone to deploy on the current mission:</p>
            <div id="droneSelectionOptions" class="drone-list">
                <!-- Drone options will be inserted here -->
            </div>
            <button id="cancelDroneSelectionBtn">Cancel</button>
        </div>
    </div>

    <div id="level-up-overlay" style="display: none;">
        <div class="modal fade-in">
            <h2>Level Up!</h2>
            <div class="level-up-container">
                <div>You've reached</div>
                <div class="level-up-number" id="newLevelNumber">2</div>
                <div>Rewards Unlocked:</div>
                <div class="level-up-rewards" id="levelRewards">
                    <!-- Level rewards will be inserted here -->
                </div>
            </div>
            <button class="big-btn" id="levelUpCloseBtn">CONTINUE</button>
        </div>
    </div>

    <script>
        // Game constants
        const PLANET_TYPES = [
            {
                name: "Mineral-Rich",
                color: "#6a3",
                icon: "ü™®",
                resourceDistribution: { minerals: 0.3, crystals: 0.1, exotic: 0.05, energy: 0.1, obstacle: 0.1, anomaly: 0.05 },
                description: "Rich in mineral deposits with stable atmosphere."
            },
            {
                name: "Crystal Desert",
                color: "#b72",
                icon: "üèúÔ∏è",
                resourceDistribution: { minerals: 0.1, crystals: 0.25, exotic: 0.07, energy: 0.15, obstacle: 0.2, anomaly: 0.07 },
                description: "Vast crystalline formations dot this arid landscape."
            },
            {
                name: "Ice World",
                color: "#8df",
                icon: "‚ùÑÔ∏è",
                resourceDistribution: { minerals: 0.2, crystals: 0.2, exotic: 0.08, energy: 0.05, obstacle: 0.15, anomaly: 0.06 },
                description: "Frozen surface with minerals trapped beneath glaciers."
            },
            {
                name: "Volcanic",
                color: "#d43",
                icon: "üåã",
                resourceDistribution: { minerals: 0.4, crystals: 0.05, exotic: 0.1, energy: 0.2, obstacle: 0.25, anomaly: 0.08 },
                description: "Unstable surface with frequent tremors and thermal vents."
            },
            // New planet types
            {
                name: "Gas Giant Moon",
                color: "#95a",
                icon: "üåí",
                resourceDistribution: { minerals: 0.15, crystals: 0.3, exotic: 0.15, energy: 0.2, obstacle: 0.1, anomaly: 0.1 },
                description: "Small moon orbiting a massive gas giant, rich in exotic materials."
            },
            {
                name: "Primordial Swamp",
                color: "#484",
                icon: "üåø",
                resourceDistribution: { minerals: 0.3, crystals: 0.05, exotic: 0.2, energy: 0.15, obstacle: 0.3, anomaly: 0.15 },
                description: "Thick atmosphere and bubbling biochemical pools cover the surface."
            },
            {
                name: "Radioactive Wasteland",
                color: "#c82",
                icon: "‚ò¢Ô∏è",
                resourceDistribution: { minerals: 0.25, crystals: 0.15, exotic: 0.2, energy: 0.25, obstacle: 0.2, anomaly: 0.12 },
                description: "High radiation levels but rich in energy sources. Caution advised."
            },
            {
                name: "Crystalline Network",
                color: "#6ad",
                icon: "üí†",
                resourceDistribution: { minerals: 0.05, crystals: 0.4, exotic: 0.15, energy: 0.1, obstacle: 0.15, anomaly: 0.2 },
                description: "Strange geometric crystal formations create complex natural networks."
            },
            // Additional planet types
            {
                name: "Quantum Flux Plains",
                color: "#a5d",
                icon: "‚öõÔ∏è",
                resourceDistribution: { minerals: 0.1, crystals: 0.2, exotic: 0.3, energy: 0.2, obstacle: 0.1, anomaly: 0.25 },
                description: "Reality itself seems unstable here, with frequent quantum fluctuations."
            },
            {
                name: "Ancient Megastructure",
                color: "#da7",
                icon: "üèõÔ∏è",
                resourceDistribution: { minerals: 0.2, crystals: 0.3, exotic: 0.25, energy: 0.15, obstacle: 0.3, anomaly: 0.3 },
                description: "Ruins of a vast alien structure that once encircled the entire planet."
            },
            {
                name: "Bioluminescent Forest",
                color: "#5c8",
                icon: "üå≥",
                resourceDistribution: { minerals: 0.15, crystals: 0.25, exotic: 0.2, energy: 0.25, obstacle: 0.2, anomaly: 0.15 },
                description: "Dense forests of glowing flora provide natural energy sources."
            },
            {
                name: "Temporal Remnant",
                color: "#9ac",
                icon: "‚è≥",
                resourceDistribution: { minerals: 0.15, crystals: 0.15, exotic: 0.35, energy: 0.15, obstacle: 0.15, anomaly: 0.3 },
                description: "A fragment of a planet caught in a time distortion, with echo-resources from multiple eras."
            }
        ];

        // Weather types
        const WEATHER_TYPES = [
            {
                name: "Clear",
                description: "Optimal conditions for exploration.",
                effect: null,
                visualEffect: null,
                chance: 0.4
            },
            {
                name: "Dust Storm",
                description: "Reduced visibility and increased energy consumption.",
                effect: { type: "energy_drain", value: 0.2 },
                visualEffect: "dust-storm",
                chance: 0.15
            },
            {
                name: "Solar Flare",
                description: "Increased energy generation from sources.",
                effect: { type: "energy_boost", value: 1.5 },
                visualEffect: "solar-flare",
                chance: 0.1
            },
            {
                name: "Acid Rain",
                description: "Corrosive precipitation damages exposed surfaces.",
                effect: { type: "harvest_penalty", value: 0.8 },
                visualEffect: "acid-rain",
                chance: 0.1
            },
            {
                name: "Electromagnetic Storm",
                description: "Scanner malfunctions, higher chance of scan failure.",
                effect: { type: "scan_penalty", value: 0.6 },
                visualEffect: "electromagnetic-storm",
                chance: 0.15
            },
            {
                name: "Crystal Resonance",
                description: "Crystal formations emit harmonic frequencies, boosting crystal yields.",
                effect: { type: "crystal_boost", value: 1.5 },
                visualEffect: "crystal-resonance",
                chance: 0.1
            },
            // Additional weather types
            {
                name: "Quantum Fluctuation",
                description: "Reality becomes unstable, randomizing resource locations.",
                effect: { type: "resource_shift", value: 0.2 },
                visualEffect: "electromagnetic-storm",
                chance: 0.05
            },
            {
                name: "Temporal Distortion",
                description: "Time flows differently, actions take longer but use less energy.",
                effect: { type: "time_dilation", value: 1.5 },
                visualEffect: null,
                chance: 0.05
            },
            {
                name: "Exotic Particle Shower",
                description: "Rare particles rain from the sky, boosting exotic material collection.",
                effect: { type: "exotic_boost", value: 2.0 },
                visualEffect: "crystal-resonance",
                chance: 0.05
            }
        ];

        // Special events
        const SPECIAL_EVENTS = [
            {
                name: "Ancient Technology",
                description: "You discover remnants of an advanced civilization. Their technology could be studied or salvaged.",
                choices: [
                    { text: "Study the technology", outcome: "You gain knowledge of efficient energy distribution. +20 energy and permanent 10% energy efficiency.", effect: { type: "upgrade", value: "energy_efficiency" } },
                    { text: "Salvage components", outcome: "You harvest valuable components. +3 crystals but the technology is lost forever.", effect: { type: "resource", value: { crystals: 3 } } }
                ]
            },
            {
                name: "Mineral Vein",
                description: "You detect an unusually pure vein of minerals just below the surface.",
                choices: [
                    { text: "Carefully extract", outcome: "Your precision approach yields high-quality minerals. +5 minerals.", effect: { type: "resource", value: { minerals: 5 } } },
                    { text: "Quick extraction", outcome: "Your rapid extraction damages some minerals but saves time. +3 minerals and +5 energy.", effect: { type: "resource", value: { minerals: 3, energy: 5 } } }
                ]
            },
            {
                name: "Energy Anomaly",
                description: "Your scanners detect an unusual energy signature emanating from nearby.",
                choices: [
                    { text: "Investigate closely", outcome: "You discover a natural energy conduit. +30 energy but it takes time to harness.", effect: { type: "resource", value: { energy: 30 } } },
                    { text: "Record and continue", outcome: "You log the anomaly for future study. Gain a permanent scanner upgrade that reveals more tiles.", effect: { type: "upgrade", value: "scanner_range" } }
                ]
            },
            {
                name: "Crystal Formation",
                description: "A shimmering crystal formation catches your sensors' attention.",
                choices: [
                    { text: "Extract crystals", outcome: "You carefully extract the crystals. +2 crystals.", effect: { type: "resource", value: { crystals: 2 } } },
                    { text: "Study formation", outcome: "You analyze the crystalline structure, improving your mining efficiency. Permanent 15% boost to crystal harvesting.", effect: { type: "upgrade", value: "crystal_efficiency" } }
                ]
            },
            {
                name: "Atmospheric Vent",
                description: "You detect a natural vent releasing gases from beneath the planet's surface.",
                choices: [
                    { text: "Harvest gas", outcome: "You collect valuable gases that can power your systems. +25 energy.", effect: { type: "resource", value: { energy: 25 } } },
                    { text: "Analyze composition", outcome: "You analyze the gases and improve your atmospheric filters. Permanent 20% reduction in movement energy costs.", effect: { type: "upgrade", value: "movement_efficiency" } }
                ]
            },
            {
                name: "Data Cache",
                description: "You discover a data storage device from a previous exploration mission.",
                choices: [
                    { text: "Download maps", outcome: "You acquire detailed surface maps of the area. Reveals 50% of the map immediately.", effect: { type: "reveal_map", value: 0.5 } },
                    { text: "Download research", outcome: "You download scientific research. Permanent 10% boost to all resource collection.", effect: { type: "upgrade", value: "collection_efficiency" } }
                ]
            },
            // Additional special events
            {
                name: "Strange Artifact",
                description: "You uncover a pulsating alien artifact of unknown origin.",
                choices: [
                    { text: "Activate it", outcome: "The artifact comes to life, revealing star charts of nearby systems. +1 tech point and reveals the entire map.", effect: { type: "tech_point", value: 1, secondary: { type: "reveal_map", value: 1.0 } } },
                    { text: "Contain for study", outcome: "You carefully secure the artifact. +3 exotic materials and gain knowledge of alien material manipulation.", effect: { type: "resource", value: { exotic: 3 }, secondary: { type: "upgrade", value: "exotic_efficiency" } } }
                ]
            },
            {
                name: "Quantum Fissure",
                description: "A tear in reality reveals a glimpse into parallel dimensions.",
                choices: [
                    { text: "Stabilize the fissure", outcome: "Your intervention prevents a catastrophic collapse and yields insights into quantum mechanics. +2 tech points.", effect: { type: "tech_point", value: 2 } },
                    { text: "Extract dimensional energy", outcome: "You siphon energy from the fissure. +50 energy, but the unstable nature causes fluctuations in your systems.", effect: { type: "resource", value: { energy: 50 }, secondary: { type: "status", value: "dimensional_instability", duration: 5 } } }
                ]
            },
            {
                name: "Ancient Relic",
                description: "A strange device of non-human origin lies partially buried in the ground.",
                choices: [
                    { text: "Extract carefully", outcome: "You recover the relic intact. A new artifact has been added to your collection!", effect: { type: "relic", value: "random" } },
                    { text: "Analyze in place", outcome: "Your scans reveal technological insights without disturbing the relic. +1 tech point and +15 energy from optimized systems.", effect: { type: "tech_point", value: 1, secondary: { type: "resource", value: { energy: 15 } } } }
                ]
            },
            {
                name: "Abandoned Drone",
                description: "You discover a damaged exploration drone from a previous mission.",
                choices: [
                    { text: "Salvage for parts", outcome: "You dismantle the drone for valuable components. +4 minerals, +2 crystals, and +1 exotic material.", effect: { type: "resource", value: { minerals: 4, crystals: 2, exotic: 1 } } },
                    { text: "Repair and reprogram", outcome: "After some work, you restore the drone's functionality. A new drone has been added to your fleet!", effect: { type: "drone", value: "salvaged_drone" } }
                ]
            },
            {
                name: "Subterranean Cavity",
                description: "Your scanners detect a large hollow space beneath the surface.",
                choices: [
                    { text: "Create access shaft", outcome: "You drill down to the cavity, finding a rich deposit of resources. +4 minerals, +3 crystals, and +2 exotic materials.", effect: { type: "resource", value: { minerals: 4, crystals: 3, exotic: 2 } } },
                    { text: "Deploy seismic probes", outcome: "Your detailed mapping reveals the cavity extends far deeper than expected. You gain permanent subterranean scanning capability.", effect: { type: "upgrade", value: "deep_scanning" } }
                ]
            }
        ];

        // Side mission templates
        const SIDE_MISSIONS = [
            {
                name: "Survey Expedition",
                description: "Scan {target} different tiles to complete a planetary survey.",
                generateParameters: () => {
                    const target = Math.floor(Math.random() * 3) + 3; // 3-5 tiles
                    return { target, current: 0, type: "scan" };
                },
                reward: { score: 100, resources: { energy: 15 }, xp: 15 }
            },
            {
                name: "Resource Collection",
                description: "Collect {target} {resourceType} for scientific analysis.",
                generateParameters: () => {
                    const target = Math.floor(Math.random() * 3) + 2; // 2-4 resources
                    const resourceTypes = ["minerals", "crystals", "exotic"];
                    const resourceType = resourceTypes[Math.floor(Math.random() * resourceTypes.length)];
                    return { target, current: 0, type: "collect", resourceType };
                },
                reward: { score: 150, upgrade: "random", xp: 20 }
            },
            {
                name: "Anomaly Investigation",
                description: "Locate and investigate a mysterious signal on the planet.",
                generateParameters: () => {
                    return { target: 1, current: 0, type: "anomaly", 
                             locationX: null, locationY: null }; // Will be set when placing anomaly
                },
                reward: { score: 200, resources: { crystals: 2, exotic: 1 }, xp: 25 }
            },
            {
                name: "Energy Conservation",
                description: "Complete your mission using less than {target} energy units.",
                generateParameters: () => {
                    const target = 50 + Math.floor(Math.random() * 30); // 50-80 energy
                    return { target, type: "energy_limit" };
                },
                reward: { score: 250, upgrade: "energy_capacity", xp: 30 }
            },
            // Additional side missions
            {
                name: "Exotic Material Collection",
                description: "Collect {target} exotic materials for advanced research.",
                generateParameters: () => {
                    const target = Math.floor(Math.random() * 2) + 1; // 1-2 exotic materials
                    return { target, current: 0, type: "collect", resourceType: "exotic" };
                },
                reward: { score: 300, techPoints: 1, xp: 35 }
            },
            {
                name: "Environmental Adaptation",
                description: "Survive for {target} actions during adverse weather conditions.",
                generateParameters: () => {
                    const target = Math.floor(Math.random() * 5) + 5; // 5-10 actions
                    return { target, current: 0, type: "weather_survival" };
                },
                reward: { score: 200, upgrade: "weather_protection", xp: 25 }
            },
            {
                name: "Resource Efficiency",
                description: "Build your base using only {target} minerals instead of 3.",
                generateParameters: () => {
                    return { target: 2, type: "efficient_construction" };
                },
                reward: { score: 250, resources: { minerals: 3 }, xp: 30 }
            },
            {
                name: "Planetary Cartography",
                description: "Reveal {target}% of the planet's surface.",
                generateParameters: () => {
                    const target = Math.floor(Math.random() * 20) + 60; // 60-80% of the map
                    return { target, type: "map_reveal" };
                },
                reward: { score: 300, techPoints: 1, xp: 40 }
            }
        ];

        // Achievements
        const ACHIEVEMENTS = [
            {
                id: "first_steps",
                name: "First Steps",
                description: "Complete your first planetary mission.",
                icon: "üöÄ",
                unlocked: false,
                bonus: 50,
                progress: { current: 0, target: 1 }
            },
            {
                id: "resource_collector",
                name: "Resource Collector",
                description: "Collect a total of 50 resources across all missions.",
                icon: "üß∞",
                unlocked: false,
                bonus: 100,
                progress: { current: 0, target: 50 }
            },
            {
                id: "efficient_explorer",
                name: "Efficient Explorer",
                description: "Achieve 80% efficiency on a mission.",
                icon: "‚öôÔ∏è",
                unlocked: false,
                bonus: 150,
                progress: { current: 0, target: 80 }
            },
            {
                id: "anomaly_analyst",
                name: "Anomaly Analyst",
                description: "Discover and investigate 3 anomalies.",
                icon: "üîç",
                unlocked: false,
                bonus: 200,
                progress: { current: 0, target: 3 }
            },
            {
                id: "base_builder",
                name: "Base Builder",
                description: "Build a base on 5 different planets.",
                icon: "üèóÔ∏è",
                unlocked: false,
                bonus: 150,
                progress: { current: 0, target: 5 }
            },
            {
                id: "crystal_connoisseur",
                name: "Crystal Connoisseur",
                description: "Collect a total of 20 crystals across all missions.",
                icon: "üíé",
                unlocked: false,
                bonus: 120,
                progress: { current: 0, target: 20 }
            },
            {
                id: "planetary_surveyor",
                name: "Planetary Surveyor",
                description: "Complete 3 survey side missions.",
                icon: "üì°",
                unlocked: false,
                bonus: 180,
                progress: { current: 0, target: 3 }
            },
            {
                id: "weather_withstander",
                name: "Weather Withstander",
                description: "Successfully complete a mission during severe weather.",
                icon: "üå™Ô∏è",
                unlocked: false,
                bonus: 200,
                progress: { current: 0, target: 1 }
            },
            // Additional achievements
            {
                id: "exotic_explorer",
                name: "Exotic Explorer",
                description: "Collect a total of 10 exotic materials.",
                icon: "üß™",
                unlocked: false,
                bonus: 250,
                progress: { current: 0, target: 10 }
            },
            {
                id: "drone_commander",
                name: "Drone Commander",
                description: "Deploy drones 15 times.",
                icon: "ü§ñ",
                unlocked: false,
                bonus: 200,
                progress: { current: 0, target: 15 }
            },
            {
                id: "tech_pioneer",
                name: "Tech Pioneer",
                description: "Unlock 5 technologies in the tech tree.",
                icon: "üî¨",
                unlocked: false,
                bonus: 300,
                progress: { current: 0, target: 5 }
            },
            {
                id: "quantum_theorist",
                name: "Quantum Theorist",
                description: "Explore a Quantum Flux Plains planet.",
                icon: "‚öõÔ∏è",
                unlocked: false,
                bonus: 250,
                progress: { current: 0, target: 1 }
            },
            {
                id: "archaeologist",
                name: "Cosmic Archaeologist",
                description: "Discover 3 ancient relics.",
                icon: "üè∫",
                unlocked: false,
                bonus: 350,
                progress: { current: 0, target: 3 }
            },
            {
                id: "fleet_admiral",
                name: "Fleet Admiral",
                description: "Collect a fleet of 5 different drone types.",
                icon: "üë®‚Äç‚úàÔ∏è",
                unlocked: false,
                bonus: 400,
                progress: { current: 0, target: 5 }
            },
            {
                id: "centurion",
                name: "Centurion",
                description: "Reach a total score of 10,000 points.",
                icon: "üèÖ",
                unlocked: false,
                bonus: 500,
                progress: { current: 0, target: 10000 }
            },
            {
                id: "planetary_network",
                name: "Planetary Network",
                description: "Explore 20 planets.",
                icon: "üåê",
                unlocked: false,
                bonus: 500,
                progress: { current: 0, target: 20 }
            }
        ];

        // Upgrades
        const UPGRADES = {
            "energy_efficiency": {
                name: "Energy Optimizer",
                description: "10% reduction in energy consumption for all actions.",
                icon: "‚ö°",
                effect: { type: "efficiency", target: "energy", value: 0.9 }
            },
            "scanner_range": {
                name: "Enhanced Scanner",
                description: "Scanner reveals adjacent tiles when scanning a location.",
                icon: "üì°",
                effect: { type: "scanner", value: 1 }
            },
            "crystal_efficiency": {
                name: "Crystal Resonator",
                description: "15% chance to get an extra crystal when harvesting.",
                icon: "üíé",
                effect: { type: "bonus_chance", target: "crystals", value: 0.15 }
            },
            "movement_efficiency": {
                name: "Efficient Locomotion",
                description: "20% reduction in movement energy costs.",
                icon: "üë£",
                effect: { type: "efficiency", target: "movement", value: 0.8 }
            },
            "collection_efficiency": {
                name: "Resource Optimizer",
                description: "10% faster resource collection.",
                icon: "‚õèÔ∏è",
                effect: { type: "speed", target: "harvest", value: 0.9 }
            },
            "energy_capacity": {
                name: "Energy Capacitor",
                description: "Maximum energy capacity increased by 20.",
                icon: "üîã",
                effect: { type: "capacity", target: "energy", value: 20 }
            },
            "auto_scanner": {
                name: "Auto-Scanner",
                description: "10% chance to automatically scan adjacent tiles when moving.",
                icon: "üîç",
                effect: { type: "auto_scan", value: 0.1 }
            },
            "mineral_efficiency": {
                name: "Mineral Extractor",
                description: "15% chance to get an extra mineral when harvesting.",
                icon: "üî∑",
                effect: { type: "bonus_chance", target: "minerals", value: 0.15 }
            },
            "exotic_efficiency": {
                name: "Exotic Material Analyzer",
                description: "25% chance to get an extra exotic material when harvesting.",
                icon: "üß™",
                effect: { type: "bonus_chance", target: "exotic", value: 0.25 }
            },
            "weather_protection": {
                name: "Atmospheric Shield",
                description: "Reduces negative effects of adverse weather by 30%.",
                icon: "üõ°Ô∏è",
                effect: { type: "weather_resistance", value: 0.7 }
            },
            "deep_scanning": {
                name: "Deep Scanning Array",
                description: "20% chance to reveal resources on unexplored adjacent tiles when scanning.",
                icon: "üìä",
                effect: { type: "deep_scan", value: 0.2 }
            },
            "drone_efficiency": {
                name: "Drone Control System",
                description: "Drones recover 20% faster and perform actions 15% more efficiently.",
                icon: "ü§ñ",
                effect: { type: "drone_boost", value: { recovery: 0.8, efficiency: 0.85 } }
            }
        };

        // Tech tree
        const TECH_TREE = [
            {
                id: "energy_systems",
                name: "Advanced Energy Systems",
                description: "More efficient energy utilization and storage.",
                icon: "‚ö°",
                cost: 1,
                unlocked: false,
                position: 0,
                requirements: [],
                effects: [
                    { description: "20% reduction in energy consumption", type: "efficiency", target: "energy", value: 0.8 },
                    { description: "+30 maximum energy capacity", type: "capacity", target: "energy", value: 30 }
                ]
            },
            {
                id: "scanning_technology",
                name: "Advanced Scanning",
                description: "Improved scanning range and accuracy.",
                icon: "üì°",
                cost: 1,
                unlocked: false,
                position: 1,
                requirements: [],
                effects: [
                    { description: "Scan reveals entire 3x3 area", type: "scanner", value: 2 },
                    { description: "50% chance to fully reveal scanned tiles", type: "scan_reveal", value: 0.5 }
                ]
            },
            {
                id: "mineral_processing",
                name: "Mineral Processing",
                description: "More efficient mineral extraction and utilization.",
                icon: "üî∑",
                cost: 1,
                unlocked: false,
                position: 2,
                requirements: [],
                effects: [
                    { description: "30% chance to get extra minerals when harvesting", type: "bonus_chance", target: "minerals", value: 0.3 },
                    { description: "Base construction requires only 2 minerals", type: "reduced_cost", target: "base", resource: "minerals", value: 2 }
                ]
            },
            {
                id: "crystal_harmonics",
                name: "Crystal Harmonics",
                description: "Advanced crystal manipulation techniques.",
                icon: "üíé",
                cost: 1,
                unlocked: false,
                position: 3,
                requirements: [],
                effects: [
                    { description: "30% chance to get extra crystals when harvesting", type: "bonus_chance", target: "crystals", value: 0.3 },
                    { description: "Ship construction requires only 1 crystal", type: "reduced_cost", target: "ship", resource: "crystals", value: 1 }
                ]
            },
            {
                id: "propulsion_systems",
                name: "Advanced Propulsion",
                description: "More efficient movement systems.",
                icon: "üöÄ",
                cost: 2,
                unlocked: false,
                position: 4,
                requirements: ["energy_systems"],
                effects: [
                    { description: "40% reduction in movement energy costs", type: "efficiency", target: "movement", value: 0.6 },
                    { description: "Can move diagonally", type: "diagonal_movement", value: true }
                ]
            },
            {
                id: "exotic_material_science",
                name: "Exotic Material Science",
                description: "Advanced understanding of exotic materials.",
                icon: "üß™",
                cost: 2,
                unlocked: false,
                position: 5,
                requirements: ["crystal_harmonics"],
                effects: [
                    { description: "50% chance to get extra exotic materials when harvesting", type: "bonus_chance", target: "exotic", value: 0.5 },
                    { description: "Can transmute 2 crystals into 1 exotic material", type: "transmutation", from: "crystals", to: "exotic", ratio: 0.5 }
                ]
            },
            {
                id: "weather_systems",
                name: "Advanced Weather Systems",
                description: "Better adaptation to planetary weather conditions.",
                icon: "üå™Ô∏è",
                cost: 2,
                unlocked: false,
                position: 6,
                requirements: ["scanning_technology"],
                effects: [
                    { description: "Negative weather effects reduced by 50%", type: "weather_resistance", value: 0.5 },
                    { description: "Positive weather effects increased by 25%", type: "weather_boost", value: 1.25 }
                ]
            },
            {
                id: "drone_technology",
                name: "Advanced Drone Systems",
                description: "Improved drone control and functionality.",
                icon: "ü§ñ",
                cost: 2,
                unlocked: false,
                position: 7,
                requirements: ["mineral_processing"],
                effects: [
                    { description: "Drones recover 40% faster", type: "drone_recovery", value: 0.6 },
                    { description: "Drones perform actions 30% more efficiently", type: "drone_efficiency", value: 0.7 },
                    { description: "Can deploy 2 drones simultaneously", type: "drone_capacity", value: 2 }
                ]
            },
            {
                id: "quantum_computing",
                name: "Quantum Computing",
                description: "Advanced computational capabilities using quantum principles.",
                icon: "‚öõÔ∏è",
                cost: 3,
                unlocked: false,
                position: 8,
                requirements: ["exotic_material_science", "propulsion_systems"],
                effects: [
                    { description: "20% chance to not consume energy when performing actions", type: "energy_conservation", value: 0.2 },
                    { description: "Can predict resource locations with 30% accuracy", type: "resource_prediction", value: 0.3 }
                ]
            },
            {
                id: "planetary_terraforming",
                name: "Planetary Terraforming",
                description: "Ability to modify planetary environments.",
                icon: "üåç",
                cost: 3,
                unlocked: false,
                position: 9,
                requirements: ["weather_systems", "drone_technology"],
                effects: [
                    { description: "Can convert obstacles into usable terrain", type: "obstacle_conversion", value: true },
                    { description: "25% chance to improve tile type when scanning", type: "tile_improvement", value: 0.25 }
                ]
            },
            {
                id: "temporal_mechanics",
                name: "Temporal Mechanics",
                description: "Understanding and manipulation of time-space properties.",
                icon: "‚è±Ô∏è",
                cost: 4,
                unlocked: false,
                position: 10,
                requirements: ["quantum_computing"],
                effects: [
                    { description: "Actions complete 40% faster", type: "time_efficiency", value: 0.6 },
                    { description: "Can reverse the last action once per mission", type: "time_reversal", value: 1 }
                ]
            },
            {
                id: "cosmic_harmonization",
                name: "Cosmic Harmonization",
                description: "Perfect alignment with the cosmic forces of the universe.",
                icon: "‚ú®",
                cost: 5,
                unlocked: false,
                position: 11,
                requirements: ["temporal_mechanics", "planetary_terraforming"],
                effects: [
                    { description: "50% chance to not consume resources when building", type: "resource_conservation", value: 0.5 },
                    { description: "Can teleport once per mission to any revealed tile", type: "teleportation", value: 1 },
                    { description: "All efficiency bonuses increased by 20%", type: "global_efficiency_boost", value: 1.2 }
                ]
            }
        ];

        // Drones
        const DRONES = [
            {
                id: "scanner_drone",
                name: "Scanner Drone MK-I",
                description: "Specialized drone that scans a 3x3 area.",
                icon: "üîç",
                energyCost: 10,
                cooldown: 3, // turns
                unlocked: true,
                action: {
                    type: "scan_area",
                    range: 1,
                    revealChance: 0.3
                }
            },
            {
                id: "collector_drone",
                name: "Collector Drone MK-I",
                description: "Specialized drone that collects resources from a targeted tile.",
                icon: "üß≤",
                energyCost: 15,
                cooldown: 4,
                unlocked: false,
                unlockLevel: 3,
                action: {
                    type: "collect",
                    efficiency: 1.2
                }
            },
            {
                id: "energy_drone",
                name: "Energy Drone MK-I",
                description: "Drone that extracts energy from surrounding environment.",
                icon: "‚ö°",
                energyCost: 5,
                cooldown: 5,
                unlocked: false,
                unlockLevel: 5,
                action: {
                    type: "generate_energy",
                    amount: 25
                }
            },
            {
                id: "explorer_drone",
                name: "Explorer Drone MK-I",
                description: "Fast drone that reveals a path through unexplored terrain.",
                icon: "üöÅ",
                energyCost: 20,
                cooldown: 6,
                unlocked: false,
                unlockLevel: 7,
                action: {
                    type: "explore_path",
                    length: 4
                }
            },
            {
                id: "shield_drone",
                name: "Shield Drone MK-I",
                description: "Provides protection against adverse weather and hazards.",
                icon: "üõ°Ô∏è",
                energyCost: 15,
                cooldown: 8,
                unlocked: false,
                unlockLevel: 8,
                action: {
                    type: "protect",
                    duration: 5, // turns
                    efficiency: 0.5 // reduces negative effects by 50%
                }
            },
            {
                id: "quantum_drone",
                name: "Quantum Drone MK-I",
                description: "Advanced drone that can manipulate quantum probabilities to locate rare resources.",
                icon: "‚öõÔ∏è",
                energyCost: 30,
                cooldown: 10,
                unlocked: false,
                unlockLevel: 10,
                action: {
                    type: "predict_resources",
                    accuracy: 0.7,
                    range: 2
                }
            },
            {
                id: "salvaged_drone",
                name: "Salvaged Drone",
                description: "Repurposed drone with mixed capabilities.",
                icon: "üîß",
                energyCost: 15,
                cooldown: 5,
                unlocked: false,
                action: {
                    type: "random",
                    possibilities: ["scan_area", "collect", "generate_energy"]
                }
            }
        ];

        // Ancient Relics (collectible artifacts that provide passive bonuses)
        const RELICS = [
            {
                id: "energy_crystal",
                name: "Ancient Energy Crystal",
                description: "A perfectly preserved crystal that resonates with energy.",
                icon: "üí†",
                discovered: false,
                effect: {
                    description: "Passive energy regeneration +0.05 per second",
                    type: "energy_regen",
                    value: 0.05
                }
            },
            {
                id: "quantum_compass",
                name: "Quantum Compass",
                description: "Device that identifies the optimal path through any terrain.",
                icon: "üß≠",
                discovered: false,
                effect: {
                    description: "Movement costs reduced by 25%",
                    type: "movement_discount",
                    value: 0.75
                }
            },
            {
                id: "resonance_key",
                name: "Resonance Key",
                description: "Mysterious device that seems to interact with crystalline structures.",
                icon: "üîë",
                discovered: false,
                effect: {
                    description: "Crystal yields increased by 30%",
                    type: "crystal_yield",
                    value: 1.3
                }
            },
            {
                id: "temporal_lens",
                name: "Temporal Lens",
                description: "Artifact that allows glimpses into different timestreams.",
                icon: "üîé",
                discovered: false,
                effect: {
                    description: "10% chance to repeat actions without energy cost",
                    type: "action_repeat",
                    value: 0.1
                }
            },
            {
                id: "void_shard",
                name: "Void Shard",
                description: "Fragment of material that seems to exist partially in another dimension.",
                icon: "üîÆ",
                discovered: false,
                effect: {
                    description: "Exotic material yields doubled",
                    type: "exotic_yield",
                    value: 2.0
                }
            },
            {
                id: "harmonic_stabilizer",
                name: "Harmonic Stabilizer",
                description: "Device that generates a field of perfect environmental harmony.",
                icon: "üìø",
                discovered: false,
                effect: {
                    description: "Weather effects halved (negative) or amplified by 50% (positive)",
                    type: "weather_control",
                    negative_value: 0.5,
                    positive_value: 1.5
                }
            },
            {
                id: "neural_matrix",
                name: "Neural Matrix",
                description: "Crystalline structure with patterns resembling synaptic connections.",
                icon: "üß†",
                discovered: false,
                effect: {
                    description: "XP gain increased by 25%",
                    type: "xp_boost",
                    value: 1.25
                }
            },
            {
                id: "architects_cipher",
                name: "Architect's Cipher",
                description: "Data storage device containing advanced construction techniques.",
                icon: "üìú",
                discovered: false,
                effect: {
                    description: "Base and ship construction costs reduced by 1 resource",
                    type: "construction_discount",
                    value: 1
                }
            }
        ];

        // Level system
        const LEVEL_SYSTEM = {
            currentLevel: 1,
            currentXP: 0,
            getRequiredXP: (level) => Math.floor(100 * Math.pow(1.5, level - 1)),
            getLevelRewards: (level) => {
                const rewards = [];
                
                // Always give tech points
                rewards.push({
                    type: "tech_point",
                    amount: 1,
                    icon: "üß™",
                    name: "Tech Point",
                    description: "Use in the tech tree to unlock new technologies"
                });
                
                // Every 2 levels, increase max energy
                if (level % 2 === 0) {
                    rewards.push({
                        type: "max_energy",
                        amount: 10,
                        icon: "‚ö°",
                        name: "Energy Capacity",
                        description: "+10 maximum energy"
                    });
                }
                
                // Every 3 levels, unlock a new drone
                if (level % 3 === 0) {
                    // Find the next drone to unlock at this level
                    const drone = DRONES.find(d => d.unlockLevel === level);
                    if (drone) {
                        rewards.push({
                            type: "drone",
                            droneId: drone.id,
                            icon: drone.icon,
                            name: drone.name,
                            description: "New drone unlocked"
                        });
                    }
                }
                
                // Every 5 levels, give a special reward
                if (level % 5 === 0) {
                    rewards.push({
                        type: "special",
                        specialType: "resource_efficiency",
                        icon: "üåü",
                        name: "Resource Mastery",
                        description: "All resource collection efficiency increased by 10%"
                    });
                }
                
                return rewards;
            }
        };

        // Planet names
        const PLANET_NAMES = [
            "Alpha-427", "Proxima", "Nova-9", "Kepler-B", "Tau Ceti", "Osiris",
            "Gliese-667", "Hyperion", "Atlas", "Kronos", "Eos", "Triton",
            // New planet names
            "Zephyr", "Helios Prime", "Theia", "Calypso", "Elysium", "Nereid",
            "Oberon", "Pandora", "Rhea", "Tethys", "Umbra", "Vortex",
            "Xenon", "Ymir", "Zaniah", "Antares", "Bellerophon", "Cressida",
            // Additional planet names
            "Nyx", "Orion", "Polaris", "Quantum Nexus", "Resonance", "Sigma Prime",
            "Thalassa", "Umbral Void", "Veritas", "Wyvern", "Xanadu", "Yggdrasil",
            "Zeta Reticuli", "Aegis", "Bifrost", "Celestia", "Dione", "Elara",
            "Fenrir", "Ganymede", "Harmonia", "Io", "Janus", "Krios", "Leda", "Mimas"
        ];

        // Game state variables
        let canvas, ctx;
        let gridSize = 6;
        let baseGridSize = 6; // Store user preference
        let tileSize;
        let grid = []; // Initialize grid as empty array
        let missionNumber = 1;
        let tooltipElement = null;
        let gameActive = false; // Track if game has started
        let energyDrainTimer = null;
        let animationTimer = null;
        let planetSeed = Math.floor(Math.random() * 1000000); // Random seed for planet generation
        let weatherTimer = null;
        let currentWeather = null;
        let weatherEffectElement = null;
        let fps = 0;
        let lastFrameTime = 0;
        let showFps = false;
        let soundEnabled = true;
        let musicEnabled = true;
        let backgroundMusic = null;
        let soundEffects = {};
        let totalScore = 0;
        let totalResources = 0;
        let totalExoticCollected = 0;
        let planetsExplored = 0;
        let activeAnomalies = [];
        let activeSideMissions = [];
        let specialMission = null;
        let upgrades = [];
        let foundAnomalies = 0;
        let basesBuilt = 0;
        let surveyMissionsCompleted = 0;
        let weatherSurvivals = 0;
        let techPoints = 0;
        let difficulty = "normal"; // easy, normal, hard, extreme
        let notificationTimeout = null;
        let visualEffectsLevel = "medium"; // low, medium, high
        let activeDrones = [];
        let deployedDrones = [];
        let discoveredRelics = [];
        let diagonalMovementEnabled = false;
        let timeReversalAvailable = false;
        let teleportAvailable = false;
        let currentLevel = 1;
        let currentXP = 0;
        let droneCapacity = 1;

        // Current planet data
        let currentPlanet = {
            type: null,
            name: null,
            color: null,
            icon: null
        };

        // Robot state
        const robot = {
            x: 0,
            y: 0,
            energy: 100,
            maxEnergy: 100,
            minerals: 0,
            crystals: 0,
            exotic: 0,
            hasBase: false,
            shipConstructed: false,
            statusEffects: [],
            baseLocation: null,
            busy: false,
            actionTimeRemaining: 0,
            actionMaxTime: 0,
            actionProgress: 0,
            currentAction: null,
            actionCompletionFunction: null,
            actionTimer: null,
            revealedTiles: 0,
            scannedTiles: 0,
            actionsPerformed: 0,
            missionScore: 0,
            lastAction: null, // For time reversal ability
            passive_energy_regen: 0 // For relics and upgrades
        };

        // Load game data from localStorage
        function loadGameData() {
            const savedData = localStorage.getItem('cosmicSwarmEnhancedData');
            if (savedData) {
                try {
                    const data = JSON.parse(savedData);
                    totalScore = data.totalScore || 0;
                    totalResources = data.totalResources || 0;
                    totalExoticCollected = data.totalExoticCollected || 0;
                    planetsExplored = data.planetsExplored || 0;
                    foundAnomalies = data.foundAnomalies || 0;
                    basesBuilt = data.basesBuilt || 0;
                    surveyMissionsCompleted = data.surveyMissionsCompleted || 0;
                    weatherSurvivals = data.weatherSurvivals || 0;
                    difficulty = data.difficulty || "normal";
                    baseGridSize = data.baseGridSize || 6;
                    techPoints = data.techPoints || 0;
                    visualEffectsLevel = data.visualEffectsLevel || "medium";
                    currentLevel = data.currentLevel || 1;
                    currentXP = data.currentXP || 0;
                    droneCapacity = data.droneCapacity || 1;
                    diagonalMovementEnabled = data.diagonalMovementEnabled || false;
                    timeReversalAvailable = data.timeReversalAvailable || false;
                    teleportAvailable = data.teleportAvailable || false;

                    // Load achievements
                    if (data.achievements) {
                        for (let i = 0; i < ACHIEVEMENTS.length; i++) {
                            if (data.achievements[i]) {
                                ACHIEVEMENTS[i].unlocked = data.achievements[i].unlocked;
                                ACHIEVEMENTS[i].progress = data.achievements[i].progress || ACHIEVEMENTS[i].progress;
                            }
                        }
                    }

                    // Load upgrades
                    if (data.upgrades) {
                        upgrades = data.upgrades;
                    }

                    // Load tech tree
                    if (data.techTree) {
                        for (let i = 0; i < TECH_TREE.length; i++) {
                            if (data.techTree[i]) {
                                TECH_TREE[i].unlocked = data.techTree[i].unlocked;
                            }
                        }
                    }

                    // Load drones
                    if (data.drones) {
                        for (let i = 0; i < DRONES.length; i++) {
                            if (data.drones[i]) {
                                DRONES[i].unlocked = data.drones[i].unlocked;
                            }
                        }
                    }

                    // Load relics
                    if (data.relics) {
                        for (let i = 0; i < RELICS.length; i++) {
                            if (data.relics[i]) {
                                RELICS[i].discovered = data.relics[i].discovered;
                                if (RELICS[i].discovered) {
                                    discoveredRelics.push(RELICS[i]);
                                }
                            }
                        }
                    }

                    // Update UI
                    updateGameDataDisplay();
                } catch (e) {
                    console.error("Error loading saved game data:", e);
                }
            }
        }

        // Save game data to localStorage
        function saveGameData() {
            const data = {
                totalScore,
                totalResources,
                totalExoticCollected,
                planetsExplored,
                foundAnomalies,
                basesBuilt,
                surveyMissionsCompleted,
                weatherSurvivals,
                difficulty,
                baseGridSize,
                techPoints,
                visualEffectsLevel,
                achievements: ACHIEVEMENTS,
                upgrades,
                techTree: TECH_TREE,
                drones: DRONES,
                relics: RELICS,
                currentLevel,
                currentXP,
                droneCapacity,
                diagonalMovementEnabled,
                timeReversalAvailable,
                teleportAvailable
            };

            localStorage.setItem('cosmicSwarmEnhancedData', JSON.stringify(data));
        }

        // Export save data as string
        function exportSaveData() {
            const saveData = localStorage.getItem('cosmicSwarmEnhancedData');
            if (saveData) {
                const encodedData = btoa(saveData);
                return encodedData;
            }
            return null;
        }

        // Import save data from string
        function importSaveData(encodedData) {
            try {
                const decodedData = atob(encodedData);
                localStorage.setItem('cosmicSwarmEnhancedData', decodedData);
                loadGameData();
                showNotification("Save data imported successfully!");
                return true;
            } catch (e) {
                console.error("Error importing save data:", e);
                showNotification("Error importing save data. Invalid format.");
                return false;
            }
        }

        // Update game data display
        function updateGameDataDisplay() {
            document.getElementById('totalScore').textContent = totalScore;
            document.getElementById('planetsExplored').textContent = planetsExplored;
            document.getElementById('totalResources').textContent = totalResources;
            document.getElementById('techPoints').textContent = techPoints;
            document.getElementById('playerLevel').textContent = currentLevel;
            document.getElementById('currentXP').textContent = currentXP;
            
            const requiredXP = LEVEL_SYSTEM.getRequiredXP(currentLevel);
            document.getElementById('requiredXP').textContent = requiredXP;
            document.getElementById('nextLevel').textContent = currentLevel + 1;
            
            // Update XP bar
            const xpPercentage = (currentXP / requiredXP) * 100;
            document.getElementById('xpBar').style.width = `${xpPercentage}%`;

            // Update difficulty setting
            document.getElementById('difficultySelect').value = difficulty;

            // Update grid size setting
            document.getElementById('gridSizeSelect').value = baseGridSize.toString();

            // Update visual effects setting
            document.getElementById('visualEffectsSelect').value = visualEffectsLevel;

            // Update FPS display setting
            document.getElementById('showFpsCheckbox').checked = showFps;

            // Display upgrades
            updateUpgradesDisplay();

            // Update tech tree display
            updateTechTreeDisplay();

            // Update drone display
            updateDroneDisplay();
        }

        // Update upgrades display
        function updateUpgradesDisplay() {
            const upgradesContainer = document.getElementById('upgrades');
            upgradesContainer.innerHTML = '';

            for (const upgradeId of upgrades) {
                if (UPGRADES[upgradeId]) {
                    const upgradeElement = document.createElement('div');
                    upgradeElement.className = 'upgrade';
                    upgradeElement.title = UPGRADES[upgradeId].description;
                    upgradeElement.textContent = UPGRADES[upgradeId].icon + ' ' + UPGRADES[upgradeId].name;
                    upgradesContainer.appendChild(upgradeElement);
                }
            }
        }

        // Update tech tree display
        function updateTechTreeDisplay() {
            const techNodesContainer = document.getElementById('techNodes');
            techNodesContainer.innerHTML = '';

            // Create nodes
            for (const tech of TECH_TREE) {
                // Check if requirements are met to make it available
                const requirementsMet = tech.requirements.every(reqId => {
                    const requiredTech = TECH_TREE.find(t => t.id === reqId);
                    return requiredTech && requiredTech.unlocked;
                });

                const available = !tech.unlocked && requirementsMet;

                // Create node element
                const techNode = document.createElement('div');
                techNode.className = 'tech-node';
                if (tech.unlocked) techNode.classList.add('unlocked');
                if (available) techNode.classList.add('available');
                
                techNode.innerHTML = `
                    <div class="tech-node-icon">${tech.icon}</div>
                    <div class="tech-tooltip">
                        <div class="tech-tooltip-title">${tech.name}</div>
                        <div class="tech-tooltip-desc">${tech.description}</div>
                        <div class="tech-tooltip-cost">Cost: ${tech.cost} tech point${tech.cost > 1 ? 's' : ''}</div>
                        ${tech.effects.map(effect => `<div class="tech-tooltip-effect">‚Ä¢ ${effect.description}</div>`).join('')}
                    </div>
                `;

                // Add click handler for available techs
                if (available) {
                    techNode.addEventListener('click', () => {
                        if (techPoints >= tech.cost) {
                            unlockTechnology(tech.id);
                        } else {
                            showNotification(`Not enough tech points! Need ${tech.cost} points.`);
                        }
                    });
                }

                techNodesContainer.appendChild(techNode);
            }
        }

        // Unlock a technology
        function unlockTechnology(techId) {
            const tech = TECH_TREE.find(t => t.id === techId);
            if (!tech || tech.unlocked || techPoints < tech.cost) return;
            
            // Unlock the technology
            tech.unlocked = true;
            techPoints -= tech.cost;
            
            // Apply technology effects
            for (const effect of tech.effects) {
                applyTechnologyEffect(effect);
            }
            
            // Update displays
            updateGameDataDisplay();
            
            // Show unlock notification
            document.getElementById('techUnlockName').textContent = tech.name;
            document.getElementById('techUnlockDescription').textContent = tech.description;
            
            // Display effects
            const effectsContainer = document.getElementById('techUnlockEffects');
            effectsContainer.innerHTML = '<div>Effects:</div>';
            for (const effect of tech.effects) {
                const effectDiv = document.createElement('div');
                effectDiv.innerHTML = `<span>‚Ä¢ ${effect.description}</span>`;
                effectsContainer.appendChild(effectDiv);
            }
            
            document.getElementById('tech-unlock-overlay').style.display = 'flex';
            
            // Update achievement progress
            updateAchievementProgress("tech_pioneer", 1);
            
            // Save game
            saveGameData();
            
            // Play sound effect
            playSoundEffect('discovery');
        }
        
        // Apply a technology effect
        function applyTechnologyEffect(effect) {
            switch (effect.type) {
                case "efficiency":
                    // Will be applied dynamically when calculating costs
                    break;
                case "capacity":
                    if (effect.target === "energy") {
                        robot.maxEnergy += effect.value;
                        robot.energy = Math.min(robot.maxEnergy, robot.energy + effect.value);
                    }
                    break;
                case "scanner":
                    // Will be applied dynamically when scanning
                    break;
                case "scan_reveal":
                    // Will be applied dynamically when scanning
                    break;
                case "bonus_chance":
                    // Will be applied dynamically when harvesting
                    break;
                case "reduced_cost":
                    // Will be applied dynamically when building
                    break;
                case "diagonal_movement":
                    diagonalMovementEnabled = true;
                    break;
                case "transmutation":
                    // Implemented in UI for resource conversion
                    break;
                case "weather_resistance":
                    // Will be applied dynamically with weather effects
                    break;
                case "weather_boost":
                    // Will be applied dynamically with weather effects
                    break;
                case "drone_recovery":
                    // Will be applied dynamically with drones
                    break;
                case "drone_efficiency":
                    // Will be applied dynamically with drones
                    break;
                case "drone_capacity":
                    droneCapacity = effect.value;
                    break;
                case "energy_conservation":
                    // Will be applied dynamically when performing actions
                    break;
                case "resource_prediction":
                    // Will be applied dynamically when exploring
                    break;
                case "obstacle_conversion":
                    // New ability to convert obstacles
                    break;
                case "tile_improvement":
                    // Will be applied dynamically when scanning
                    break;
                case "time_efficiency":
                    // Will be applied dynamically to action timers
                    break;
                case "time_reversal":
                    timeReversalAvailable = true;
                    break;
                case "resource_conservation":
                    // Will be applied dynamically when building
                    break;
                case "teleportation":
                    teleportAvailable = true;
                    break;
                case "global_efficiency_boost":
                    // Will be applied dynamically to all efficiency calculations
                    break;
            }
        }
        
        // Close tech unlock overlay
        function closeTechUnlockOverlay() {
            document.getElementById('tech-unlock-overlay').style.display = 'none';
            playSoundEffect('button_click');
        }
        
        // Update drone display
        function updateDroneDisplay() {
            const activeDrone = DRONES.find(d => d.unlocked && d.id === "scanner_drone") || null;
            
            if (activeDrone) {
                document.getElementById('droneName').textContent = activeDrone.name;
                document.getElementById('droneIcon').textContent = activeDrone.icon;
                
                // Check if drone is deployed or on cooldown
                const deployedDrone = deployedDrones.find(d => d.id === activeDrone.id);
                if (deployedDrone) {
                    if (deployedDrone.cooldownRemaining > 0) {
                        document.getElementById('droneStatus').textContent = `Recharging (${deployedDrone.cooldownRemaining} turns)`;
                        document.getElementById('droneDeployBtn').disabled = true;
                    } else {
                        document.getElementById('droneStatus').textContent = 'Ready';
                        document.getElementById('droneDeployBtn').disabled = false;
                    }
                } else {
                    document.getElementById('droneStatus').textContent = 'Ready';
                    document.getElementById('droneDeployBtn').disabled = false;
                }
            }
            
            // Update drone list
            updateDroneListDisplay();
        }
        
        // Update drone list display
        function updateDroneListDisplay() {
            const dronesListContainer = document.getElementById('dronesList');
            dronesListContainer.innerHTML = '';
            
            for (const drone of DRONES) {
                if (drone.unlocked) {
                    const droneItem = document.createElement('div');
                    droneItem.className = 'drone-item';
                    
                    // Check drone status
                    const deployedDrone = deployedDrones.find(d => d.id === drone.id);
                    let status = 'Available';
                    let statusClass = '';
                    
                    if (deployedDrone) {
                        if (deployedDrone.cooldownRemaining > 0) {
                            status = `Recharging (${deployedDrone.cooldownRemaining})`;
                            statusClass = 'recharging';
                        } else {
                            status = 'Ready';
                        }
                    }
                    
                    droneItem.innerHTML = `
                        <div class="drone-item-left">
                            <div class="drone-item-icon">${drone.icon}</div>
                            <div class="drone-item-info">
                                <div class="drone-item-name">${drone.name}</div>
                                <div class="drone-item-desc">${drone.description}</div>
                            </div>
                        </div>
                        <div class="drone-item-status ${statusClass}">${status}</div>
                    `;
                    
                    // Add click event to select drone
                    droneItem.addEventListener('click', () => {
                        selectDrone(drone.id);
                    });
                    
                    dronesListContainer.appendChild(droneItem);
                }
            }
        }
        
        // Select a drone
        function selectDrone(droneId) {
            const drone = DRONES.find(d => d.id === droneId);
            if (drone) {
                // Set as active drone
                activeDrones = [drone];
                updateDroneDisplay();
                
                // Close drone menu
                toggleDronesMenu();
                
                showNotification(`${drone.name} selected!`);
                playSoundEffect('button_click');
            }
        }
        
        // Deploy drone
        function deployDrone() {
            if (activeDrones.length === 0) {
                showNotification("No drone selected!");
                return;
            }
            
            const drone = activeDrones[0];
            
            // Check if already deployed or on cooldown
            const existingDrone = deployedDrones.find(d => d.id === drone.id);
            if (existingDrone && existingDrone.cooldownRemaining > 0) {
                showNotification(`${drone.name} is still recharging!`);
                return;
            }
            
            // Check energy cost
            if (robot.energy < drone.energyCost) {
                showNotification(`Not enough energy to deploy ${drone.name}!`);
                return;
            }
            
            // Check if already at drone capacity
            const activeDeployments = deployedDrones.filter(d => d.cooldownRemaining === 0).length;
            if (activeDeployments >= droneCapacity) {
                showNotification(`Cannot deploy more than ${droneCapacity} drone${droneCapacity > 1 ? 's' : ''} at once!`);
                return;
            }
            
            // Deploy the drone
            robot.energy -= drone.energyCost;
            
            // Execute drone action based on type
            executeDroneAction(drone);
            
            // Add to deployed drones or update cooldown
            if (existingDrone) {
                existingDrone.cooldownRemaining = drone.cooldown;
            } else {
                deployedDrones.push({
                    id: drone.id,
                    name: drone.name,
                    cooldownRemaining: drone.cooldown
                });
            }
            
            // Update achievement progress
            updateAchievementProgress("drone_commander", 1);
            
            // Update UI
            updateDroneDisplay();
            updateUI();
            
            playSoundEffect('button_click');
        }
        
        // Execute drone action
        function executeDroneAction(drone) {
            switch (drone.action.type) {
                case "scan_area":
                    // Scan an area around the robot
                    const range = drone.action.range;
                    const revealChance = drone.action.revealChance;
                    
                    for (let y = Math.max(0, robot.y - range); y <= Math.min(gridSize - 1, robot.y + range); y++) {
                        for (let x = Math.max(0, robot.x - range); x <= Math.min(gridSize - 1, robot.x + range); x++) {
                            // Mark as scanned
                            grid[y][x].scanned = true;
                            
                            // Chance to fully reveal
                            if (Math.random() < revealChance) {
                                grid[y][x].revealed = true;
                                robot.revealedTiles++;
                            }
                        }
                    }
                    
                    addLogEntry(`${drone.name} scanned a ${range*2+1}x${range*2+1} area.`);
                    updateObjectiveDisplay();
                    break;
                
                case "collect":
                    // Collect resources from current tile
                    const tile = grid[robot.y][robot.x];
                    
                    if (tile.revealed && (tile.type === 'minerals' || tile.type === 'crystals' || tile.type === 'exotic')) {
                        let resourceType = tile.type;
                        let amount = Math.ceil(drone.action.efficiency);
                        
                        if (resourceType === 'minerals') {
                            robot.minerals += amount;
                            totalResources += amount;
                        } else if (resourceType === 'crystals') {
                            robot.crystals += amount;
                            totalResources += amount;
                        } else if (resourceType === 'exotic') {
                            robot.exotic += amount;
                            totalResources += amount;
                            totalExoticCollected += amount;
                        }
                        
                        tile.type = 'empty';
                        addLogEntry(`${drone.name} collected ${amount} ${resourceType}.`);
                        
                        // Check for resource collection side missions
                        checkSideMissionProgress("collect", { resourceType, amount });
                    } else {
                        addLogEntry(`${drone.name} found no resources to collect at this location.`);
                    }
                    
                    updateObjectiveDisplay();
                    break;
                
                case "generate_energy":
                    // Generate energy
                    const energyAmount = drone.action.amount;
                    robot.energy = Math.min(robot.maxEnergy, robot.energy + energyAmount);
                    addLogEntry(`${drone.name} generated ${energyAmount} energy.`);
                    break;
                
                case "explore_path":
                    // Reveal a path in a random direction
                    const directions = [];
                    
                    // Check all possible directions
                    if (robot.y > 0) directions.push({ dx: 0, dy: -1 }); // Up
                    if (robot.y < gridSize - 1) directions.push({ dx: 0, dy: 1 }); // Down
                    if (robot.x > 0) directions.push({ dx: -1, dy: 0 }); // Left
                    if (robot.x < gridSize - 1) directions.push({ dx: 1, dy: 0 }); // Right
                    
                    if (diagonalMovementEnabled) {
                        if (robot.y > 0 && robot.x > 0) directions.push({ dx: -1, dy: -1 }); // Up-left
                        if (robot.y > 0 && robot.x < gridSize - 1) directions.push({ dx: 1, dy: -1 }); // Up-right
                        if (robot.y < gridSize - 1 && robot.x > 0) directions.push({ dx: -1, dy: 1 }); // Down-left
                        if (robot.y < gridSize - 1 && robot.x < gridSize - 1) directions.push({ dx: 1, dy: 1 }); // Down-right
                    }
                    
                    if (directions.length > 0) {
                        // Choose a random direction
                        const direction = directions[Math.floor(Math.random() * directions.length)];
                        let pathLength = 0;
                        let currentX = robot.x;
                        let currentY = robot.y;
                        
                        // Explore in that direction up to the drone's path length
                        for (let i = 0; i < drone.action.length; i++) {
                            currentX += direction.dx;
                            currentY += direction.dy;
                            
                            // Check if still within grid bounds
                            if (currentX < 0 || currentX >= gridSize || currentY < 0 || currentY >= gridSize) {
                                break;
                            }
                            
                            // Reveal the tile
                            if (!grid[currentY][currentX].revealed) {
                                grid[currentY][currentX].scanned = true;
                                grid[currentY][currentX].revealed = true;
                                robot.revealedTiles++;
                                pathLength++;
                            }
                            
                            // Stop at obstacles
                            if (grid[currentY][currentX].type === 'obstacle') {
                                break;
                            }
                        }
                        
                        addLogEntry(`${drone.name} explored a path revealing ${pathLength} new tiles.`);
                    } else {
                        addLogEntry(`${drone.name} couldn't find a valid exploration path.`);
                    }
                    
                    updateObjectiveDisplay();
                    break;
                
                case "protect":
                    // Add protection status effect
                    robot.statusEffects = robot.statusEffects.filter(effect => effect.source !== 'drone_shield');
                    
                    robot.statusEffects.push({
                        name: "Drone Shield",
                        effect: { type: "damage_reduction", value: drone.action.efficiency },
                        duration: drone.action.duration,
                        source: 'drone_shield'
                    });
                    
                    addLogEntry(`${drone.name} deployed a protective shield that will last for ${drone.action.duration} turns.`);
                    break;
                
                case "predict_resources":
                    // Highlight tiles with resources
                    let resourcesFound = 0;
                    
                    for (let y = Math.max(0, robot.y - drone.action.range); y <= Math.min(gridSize - 1, robot.y + drone.action.range); y++) {
                        for (let x = Math.max(0, robot.x - drone.action.range); x <= Math.min(gridSize - 1, robot.x + drone.action.range); x++) {
                            // Only predict for unrevealed tiles
                            if (!grid[y][x].revealed) {
                                // Only predict with some accuracy
                                if (Math.random() < drone.action.accuracy) {
                                    if (grid[y][x].type === 'minerals' || grid[y][x].type === 'crystals' || grid[y][x].type === 'exotic') {
                                        // Mark as scanned so it appears differently
                                        grid[y][x].scanned = true;
                                        resourcesFound++;
                                    }
                                }
                            }
                        }
                    }
                    
                    addLogEntry(`${drone.name} detected ${resourcesFound} resource deposits in the vicinity.`);
                    break;
                
                case "random":
                    // Execute a random drone action from the possibilities
                    const randomActionType = drone.action.possibilities[Math.floor(Math.random() * drone.action.possibilities.length)];
                    
                    // Create a temporary drone with the random action
                    const tempDrone = { 
                        ...drone, 
                        action: {
                            type: randomActionType,
                            range: 1,
                            revealChance: 0.3,
                            efficiency: 1.0,
                            amount: 20
                        } 
                    };
                    
                    executeDroneAction(tempDrone);
                    break;
            }
            
            // Draw grid to show drone effects
            drawGrid();
        }
        
        // Toggle drones menu
        function toggleDronesMenu() {
            const menu = document.getElementById('drones-menu');
            menu.classList.toggle('active');
            
            // Update drone list display
            if (menu.classList.contains('active')) {
                updateDroneListDisplay();
            }
            
            playSoundEffect('button_click');
        }
        
        // Check if multiple drones are ready
        function showDroneSelection() {
            const availableDrones = DRONES.filter(drone => {
                const deployedDrone = deployedDrones.find(d => d.id === drone.id);
                return drone.unlocked && (!deployedDrone || deployedDrone.cooldownRemaining === 0);
            });
            
            if (availableDrones.length <= 1) {
                // If only one drone is available, use it
                if (availableDrones.length === 1) {
                    selectDrone(availableDrones[0].id);
                }
                return;
            }
            
            // Show selection overlay
            const selectionContainer = document.getElementById('droneSelectionOptions');
            selectionContainer.innerHTML = '';
            
            for (const drone of availableDrones) {
                const droneItem = document.createElement('div');
                droneItem.className = 'drone-item';
                droneItem.innerHTML = `
                    <div class="drone-item-left">
                        <div class="drone-item-icon">${drone.icon}</div>
                        <div class="drone-item-info">
                            <div class="drone-item-name">${drone.name}</div>
                            <div class="drone-item-desc">${drone.description}</div>
                        </div>
                    </div>
                    <div class="drone-item-status">Energy: ${drone.energyCost}</div>
                `;
                
                droneItem.addEventListener('click', () => {
                    selectDrone(drone.id);
                    document.getElementById('drone-selection-overlay').style.display = 'none';
                });
                
                selectionContainer.appendChild(droneItem);
            }
            
            document.getElementById('drone-selection-overlay').style.display = 'flex';
        }
        
        // Add a newly discovered relic
        function addRelic(relicId) {
            const relic = RELICS.find(r => r.id === relicId);
            if (!relic || relic.discovered) return;
            
            // Mark relic as discovered
            relic.discovered = true;
            discoveredRelics.push(relic);
            
            // Apply relic effect immediately if applicable
            if (relic.effect.type === "energy_regen") {
                robot.passive_energy_regen += relic.effect.value;
            }
            
            // Show relic discovery overlay
            document.getElementById('relicName').textContent = relic.name;
            document.getElementById('relicDescription').textContent = relic.description;
            document.getElementById('relicEffect').textContent = relic.effect.description;
            document.getElementById('relic-discovery-overlay').style.display = 'flex';
            
            // Update achievement progress
            updateAchievementProgress("archaeologist", 1);
            
            // Save game
            saveGameData();
            
            // Play sound effect
            playSoundEffect('discovery');
        }
        
        // Close relic discovery overlay
        function closeRelicDiscoveryOverlay() {
            document.getElementById('relic-discovery-overlay').style.display = 'none';
            playSoundEffect('button_click');
        }
        
        // Add experience points
        function addExperience(amount) {
            // Apply XP boost from relics if applicable
            const xpRelic = discoveredRelics.find(r => r.effect.type === "xp_boost");
            if (xpRelic) {
                amount = Math.floor(amount * xpRelic.effect.value);
            }
            
            currentXP += amount;
            const requiredXP = LEVEL_SYSTEM.getRequiredXP(currentLevel);
            
            // Check for level up
            if (currentXP >= requiredXP) {
                levelUp();
            } else {
                // Just update the XP display
                const xpPercentage = (currentXP / requiredXP) * 100;
                document.getElementById('xpBar').style.width = `${xpPercentage}%`;
                document.getElementById('currentXP').textContent = currentXP;
                document.getElementById('requiredXP').textContent = requiredXP;
            }
            
            return amount;
        }
        
        // Level up the player
        function levelUp() {
            const oldLevel = currentLevel;
            currentLevel++;
            
            // Calculate overflow XP
            let overflowXP = currentXP - LEVEL_SYSTEM.getRequiredXP(oldLevel);
            currentXP = overflowXP;
            
            // Get rewards for the new level
            const rewards = LEVEL_SYSTEM.getLevelRewards(currentLevel);
            
            // Apply rewards
            for (const reward of rewards) {
                applyLevelReward(reward);
            }
            
            // Update level display
            document.getElementById('playerLevel').textContent = currentLevel;
            document.getElementById('nextLevel').textContent = currentLevel + 1;
            
            const requiredXP = LEVEL_SYSTEM.getRequiredXP(currentLevel);
            document.getElementById('requiredXP').textContent = requiredXP;
            
            const xpPercentage = (currentXP / requiredXP) * 100;
            document.getElementById('xpBar').style.width = `${xpPercentage}%`;
            document.getElementById('currentXP').textContent = currentXP;
            
            // Show level up overlay
            document.getElementById('newLevelNumber').textContent = currentLevel;
            
            // Display rewards
            const rewardsContainer = document.getElementById('levelRewards');
            rewardsContainer.innerHTML = '';
            
            for (const reward of rewards) {
                const rewardElement = document.createElement('div');
                rewardElement.className = 'level-reward';
                rewardElement.innerHTML = `
                    <div class="reward-icon">${reward.icon}</div>
                    <div class="reward-name">${reward.name}</div>
                    <div class="reward-desc">${reward.description}</div>
                `;
                rewardsContainer.appendChild(rewardElement);
            }
            
            document.getElementById('level-up-overlay').style.display = 'flex';
            
            // Save game
            saveGameData();
            
            // Play level up sound
            playSoundEffect('achievement');
        }
        
        // Apply level reward
        function applyLevelReward(reward) {
            switch (reward.type) {
                case "tech_point":
                    techPoints += reward.amount;
                    break;
                case "max_energy":
                    robot.maxEnergy += reward.amount;
                    robot.energy = Math.min(robot.maxEnergy, robot.energy + reward.amount);
                    break;
                case "drone":
                    const drone = DRONES.find(d => d.id === reward.droneId);
                    if (drone) {
                        drone.unlocked = true;
                    }
                    break;
                case "special":
                    if (reward.specialType === "resource_efficiency") {
                        // Add a custom upgrade
                        upgrades.push("resource_mastery_" + currentLevel);
                        // This will be applied dynamically when harvesting
                    }
                    break;
            }
        }
        
        // Close level up overlay
        function closeLevelUpOverlay() {
            document.getElementById('level-up-overlay').style.display = 'none';
            playSoundEffect('button_click');
        }
        
        // Update achievement progress
        function updateAchievementProgress(achievementId, increment) {
            const achievement = ACHIEVEMENTS.find(a => a.id === achievementId);
            if (!achievement || achievement.unlocked) return;
            
            achievement.progress.current += increment;
            
            // Check if achievement is completed
            if (achievement.progress.current >= achievement.progress.target) {
                unlockAchievement(achievementId);
            }
            
            saveGameData();
        }
        
        // Unlock an achievement
        function unlockAchievement(achievementId) {
            const achievement = ACHIEVEMENTS.find(a => a.id === achievementId);
            if (!achievement || achievement.unlocked) return;
            
            achievement.unlocked = true;
            totalScore += achievement.bonus;
            
            // Show notification
            showAchievementNotification(achievement);
            
            // Save game data
            saveGameData();
        }
        
        // Reset game progress
        function resetGameProgress() {
            if (confirm("Are you sure you want to reset all progress? This cannot be undone!")) {
                totalScore = 0;
                totalResources = 0;
                totalExoticCollected = 0;
                planetsExplored = 0;
                foundAnomalies = 0;
                basesBuilt = 0;
                surveyMissionsCompleted = 0;
                weatherSurvivals = 0;
                upgrades = [];
                techPoints = 0;
                currentLevel = 1;
                currentXP = 0;
                droneCapacity = 1;
                diagonalMovementEnabled = false;
                timeReversalAvailable = false;
                teleportAvailable = false;
                discoveredRelics = [];
    
                // Reset achievements
                for (let achievement of ACHIEVEMENTS) {
                    achievement.unlocked = false;
                    achievement.progress = { current: 0, target: achievement.progress.target };
                }
                
                // Reset tech tree
                for (let tech of TECH_TREE) {
                    tech.unlocked = false;
                }
                
                // Reset drones
                for (let drone of DRONES) {
                    drone.unlocked = drone.id === "scanner_drone" ? true : false;
                }
                
                // Reset relics
                for (let relic of RELICS) {
                    relic.discovered = false;
                }
    
                saveGameData();
                updateGameDataDisplay();
    
                showNotification("Game progress has been reset!");
                
                // Return to start screen
                document.getElementById('start-game-overlay').style.display = 'flex';
                
                if (gameActive) {
                    gameActive = false;
                    if (energyDrainTimer) clearInterval(energyDrainTimer);
                    if (animationTimer) clearInterval(animationTimer);
                    if (weatherTimer) clearInterval(weatherTimer);
                    if (robot.actionTimer) clearInterval(robot.actionTimer);
                }
            }
        }
        
        // Game over function - called when energy is depleted
        function gameOver() {
            gameActive = false;
    
            // Clear all timers
            if (robot.actionTimer) clearInterval(robot.actionTimer);
            if (energyDrainTimer) clearInterval(energyDrainTimer);
            if (animationTimer) clearInterval(animationTimer);
            if (weatherTimer) clearInterval(weatherTimer);
    
            robot.actionTimer = null;
    
            // Update game over stats
            document.getElementById('gameOverPlanet').textContent = currentPlanet.name;
            document.getElementById('gameOverResources').textContent = 
                (robot.minerals + robot.crystals + robot.exotic);
            document.getElementById('gameOverScore').textContent = robot.missionScore;
    
            // Show game over overlay
            document.getElementById('game-over-overlay').style.display = 'flex';
    
            addLogEntry('CRITICAL: Energy depleted. Mission failed.', true);
    
            // Play sound effect
            playSoundEffect('game_over');
        }
    
        // Retry the current mission after failure
        function retryMission() {
            document.getElementById('game-over-overlay').style.display = 'none';
            startNewMission();
            gameActive = true;
    
            // Play sound effect
            playSoundEffect('button_click');
        }
    
        // Create weather effect layer
        function createWeatherEffectLayer() {
            if (weatherEffectElement) {
                weatherEffectElement.remove();
            }
    
            weatherEffectElement = document.createElement('div');
            weatherEffectElement.className = 'weather-effect';
            document.querySelector('.game-container').appendChild(weatherEffectElement);
        }
    
        // Set weather effect
        function setWeatherEffect(effect) {
            if (weatherEffectElement) {
                weatherEffectElement.className = 'weather-effect';
                if (effect && visualEffectsLevel !== "low") {
                    weatherEffectElement.classList.add(effect);
                }
            }
        }
    
        // Initialize the game
        window.onload = function () {
            canvas = document.getElementById('gameCanvas');
            ctx = canvas.getContext('2d');
            createTooltip();
            createWeatherEffectLayer();
    
            // Adjust canvas size for mobile if needed
            adjustCanvasSize();
            window.addEventListener('resize', adjustCanvasSize);
    
            // Add mouse/touch move listener for tooltips
            canvas.addEventListener('mousemove', handleMouseMove);
            canvas.addEventListener('touchmove', handleTouchMove);
            canvas.addEventListener('mouseout', hideTooltip);
            canvas.addEventListener('touchend', hideTooltip);
    
            // Create initial empty grid to avoid undefined errors
            grid = Array.from({ length: gridSize }, () =>
                Array.from({ length: gridSize }, () => ({
                    revealed: false,
                    scanned: false,
                    type: 'empty',
                    variant: 0
                }))
            );
    
            // Set up event listeners for UI elements
            document.getElementById('settingsBtn').addEventListener('click', toggleSettingsMenu);
            document.getElementById('shareBtn').addEventListener('click', toggleSocialMenu);
            document.getElementById('achievementsBtn').addEventListener('click', showAchievementsOverlay);
            document.getElementById('closeSettingsBtn').addEventListener('click', toggleSettingsMenu);
            document.getElementById('closeSocialBtn').addEventListener('click', toggleSocialMenu);
            document.getElementById('closeDronesBtn').addEventListener('click', toggleDronesMenu);
            document.getElementById('resetProgressBtn').addEventListener('click', resetGameProgress);
            document.getElementById('screenshotBtn').addEventListener('click', takeScreenshot);
            document.getElementById('shareSeedBtn').addEventListener('click', sharePlanetSeed);
            document.getElementById('shareScoreBtn').addEventListener('click', shareScore);
            document.getElementById('exportSaveBtn').addEventListener('click', exportSaveDataToClipboard);
            document.getElementById('importSaveBtn').addEventListener('click', importSaveDataFromClipboard);
            document.getElementById('specialEventCloseBtn').addEventListener('click', closeSpecialEvent);
            document.getElementById('acceptMissionBtn').addEventListener('click', acceptSideMission);
            document.getElementById('declineMissionBtn').addEventListener('click', declineSideMission);
            document.getElementById('achievementCloseBtn').addEventListener('click', closeAchievementNotification);
            document.getElementById('techUnlockCloseBtn').addEventListener('click', closeTechUnlockOverlay);
            document.getElementById('relicCloseBtn').addEventListener('click', closeRelicDiscoveryOverlay);
            document.getElementById('cancelDroneSelectionBtn').addEventListener('click', () => {
                document.getElementById('drone-selection-overlay').style.display = 'none';
            });
            document.getElementById('levelUpCloseBtn').addEventListener('click', closeLevelUpOverlay);
            document.getElementById('difficultySelect').addEventListener('change', changeDifficulty);
            document.getElementById('gridSizeSelect').addEventListener('change', changeGridSize);
            document.getElementById('visualEffectsSelect').addEventListener('change', changeVisualEffects);
            document.getElementById('showFpsCheckbox').addEventListener('change', toggleFpsDisplay);
            document.getElementById('musicToggle').addEventListener('click', toggleMusic);
            document.getElementById('sfxToggle').addEventListener('click', toggleSoundEffects);
            document.getElementById('droneListBtn').addEventListener('click', toggleDronesMenu);
            document.getElementById('droneDeployBtn').addEventListener('click', deployDrone);
    
            // Load game data
            loadGameData();
    
            // Initialize the first mission but don't start the game yet
            startNewMission(false);
    
            // Initialize audio
            initAudio();
    
            // Update UI with loaded data
            updateGameDataDisplay();
    
            // Make functions globally accessible
            window.startGame = startGame;
            window.startNextMission = startNextMission;
            window.retryMission = retryMission;
            window.scanTile = scanTile;
            window.buildBase = buildBase;
            window.harvestResource = harvestResource;
            window.constructShip = constructShip;
            window.moveRobot = moveRobot;
            window.deployDrone = deployDrone;
            window.toggleDronesMenu = toggleDronesMenu;
    
            // Start animation loop
            requestAnimationFrame(gameLoop);
        };
    
        // Game loop
        function gameLoop(timestamp) {
            // Calculate FPS
            if (lastFrameTime) {
                fps = Math.round(1000 / (timestamp - lastFrameTime));
            }
            lastFrameTime = timestamp;
    
            // Draw game
            drawGrid();
    
            // Request next frame
            requestAnimationFrame(gameLoop);
        }
    
// Initialize audio
function initAudio() {
    // Create audio context
    try {
        window.AudioContext = window.AudioContext || window.webkitAudioContext;
        window.audioContext = new AudioContext();
    } catch(e) {
        console.warn("Web Audio API is not supported in this browser");
        return;
    }

    // Sound effects library - using simple oscillator sounds since we can't load external files
    soundEffects = {
        'scan': createScanSound,
        'move': createMoveSound,
        'harvest': createHarvestSound,
        'build': createBuildSound,
        'launch': createLaunchSound, 
        'discovery': createDiscoverySound,
        'button_click': createButtonClickSound,
        'game_over': createGameOverSound,
        'achievement': createAchievementSound
    };
    
    // Create a simple background music oscillator
    createBackgroundMusic();
    
    // Add log message
    console.log("Audio system initialized");
}

// Play background music
function playBackgroundMusic() {
    if (!musicEnabled || !window.audioContext) return;
    
    try {
        // Stop existing music if playing
        if (backgroundMusic && backgroundMusic.oscillator) {
            backgroundMusic.oscillator.stop();
            backgroundMusic.gain.disconnect();
        }
        
        createBackgroundMusic();
        
        // Log success
        console.log("Background music started");
    } catch(e) {
        console.error("Error playing background music:", e);
    }
}

// Create background music
function createBackgroundMusic() {
    if (!window.audioContext) return;
    
    try {
        const oscillator = window.audioContext.createOscillator();
        const gainNode = window.audioContext.createGain();
        
        oscillator.type = 'sine';
        oscillator.frequency.value = 220; // A3 note
        
        gainNode.gain.value = 0.05; // Very quiet
        
        oscillator.connect(gainNode);
        gainNode.connect(window.audioContext.destination);
        
        oscillator.start();
        
        // Store references for stopping later
        backgroundMusic = {
            oscillator: oscillator,
            gain: gainNode
        };
        
        // Auto-stop after 30 seconds and restart with a different note
        setTimeout(() => {
            if (musicEnabled) {
                playBackgroundMusic();
            }
        }, 30000);
    } catch(e) {
        console.error("Error creating background music:", e);
    }
}

// Play sound effect
function playSoundEffect(sfxName) {
    if (!soundEnabled || !window.audioContext) return;
    
    try {
        // Resume audio context if suspended (browser policy)
        if (window.audioContext.state === 'suspended') {
            window.audioContext.resume();
        }
        
        // Get the sound creation function
        const soundFunction = soundEffects[sfxName];
        
        if (soundFunction) {
            soundFunction();
            console.log(`Playing sound effect: ${sfxName}`);
        }
    } catch(e) {
        console.error(`Error playing sound effect ${sfxName}:`, e);
    }
}

// Create scan sound
function createScanSound() {
    if (!window.audioContext) return;
    
    const oscillator = window.audioContext.createOscillator();
    const gainNode = window.audioContext.createGain();
    
    oscillator.type = 'sine';
    oscillator.frequency.setValueAtTime(880, window.audioContext.currentTime); // Start at A5
    oscillator.frequency.exponentialRampToValueAtTime(440, window.audioContext.currentTime + 0.3); // Glide down to A4
    
    gainNode.gain.setValueAtTime(0.5, window.audioContext.currentTime);
    gainNode.gain.exponentialRampToValueAtTime(0.01, window.audioContext.currentTime + 0.5);
    
    oscillator.connect(gainNode);
    gainNode.connect(window.audioContext.destination);
    
    oscillator.start();
    oscillator.stop(window.audioContext.currentTime + 0.5);
}

// Create move sound
function createMoveSound() {
    if (!window.audioContext) return;
    
    const oscillator = window.audioContext.createOscillator();
    const gainNode = window.audioContext.createGain();
    
    oscillator.type = 'triangle';
    oscillator.frequency.value = 300;
    
    gainNode.gain.setValueAtTime(0.3, window.audioContext.currentTime);
    gainNode.gain.exponentialRampToValueAtTime(0.01, window.audioContext.currentTime + 0.15);
    
    oscillator.connect(gainNode);
    gainNode.connect(window.audioContext.destination);
    
    oscillator.start();
    oscillator.stop(window.audioContext.currentTime + 0.15);
}

// Create harvest sound
function createHarvestSound() {
    if (!window.audioContext) return;
    
    const oscillator1 = window.audioContext.createOscillator();
    const oscillator2 = window.audioContext.createOscillator();
    const gainNode = window.audioContext.createGain();
    
    oscillator1.type = 'sawtooth';
    oscillator1.frequency.value = 220;
    
    oscillator2.type = 'sine';
    oscillator2.frequency.value = 440;
    
    gainNode.gain.setValueAtTime(0.3, window.audioContext.currentTime);
    gainNode.gain.exponentialRampToValueAtTime(0.01, window.audioContext.currentTime + 0.4);
    
    oscillator1.connect(gainNode);
    oscillator2.connect(gainNode);
    gainNode.connect(window.audioContext.destination);
    
    oscillator1.start();
    oscillator2.start();
    oscillator1.stop(window.audioContext.currentTime + 0.4);
    oscillator2.stop(window.audioContext.currentTime + 0.4);
}

// Create build sound
function createBuildSound() {
    if (!window.audioContext) return;
    
    const oscillator = window.audioContext.createOscillator();
    const gainNode = window.audioContext.createGain();
    
    oscillator.type = 'square';
    oscillator.frequency.setValueAtTime(220, window.audioContext.currentTime);
    oscillator.frequency.linearRampToValueAtTime(440, window.audioContext.currentTime + 0.1);
    oscillator.frequency.linearRampToValueAtTime(330, window.audioContext.currentTime + 0.2);
    oscillator.frequency.linearRampToValueAtTime(550, window.audioContext.currentTime + 0.3);
    
    gainNode.gain.setValueAtTime(0.3, window.audioContext.currentTime);
    gainNode.gain.exponentialRampToValueAtTime(0.01, window.audioContext.currentTime + 0.3);
    
    oscillator.connect(gainNode);
    gainNode.connect(window.audioContext.destination);
    
    oscillator.start();
    oscillator.stop(window.audioContext.currentTime + 0.3);
}

// Create launch sound
function createLaunchSound() {
    if (!window.audioContext) return;
    
    const oscillator = window.audioContext.createOscillator();
    const gainNode = window.audioContext.createGain();
    
    oscillator.type = 'sawtooth';
    oscillator.frequency.setValueAtTime(110, window.audioContext.currentTime);
    oscillator.frequency.exponentialRampToValueAtTime(880, window.audioContext.currentTime + 1.0);
    
    gainNode.gain.setValueAtTime(0.01, window.audioContext.currentTime);
    gainNode.gain.linearRampToValueAtTime(0.3, window.audioContext.currentTime + 0.1);
    gainNode.gain.exponentialRampToValueAtTime(0.01, window.audioContext.currentTime + 1.0);
    
    oscillator.connect(gainNode);
    gainNode.connect(window.audioContext.destination);
    
    oscillator.start();
    oscillator.stop(window.audioContext.currentTime + 1.0);
}

// Create discovery sound
function createDiscoverySound() {
    if (!window.audioContext) return;
    
    const oscillator1 = window.audioContext.createOscillator();
    const oscillator2 = window.audioContext.createOscillator();
    const gainNode = window.audioContext.createGain();
    
    oscillator1.type = 'sine';
    oscillator1.frequency.setValueAtTime(523.25, window.audioContext.currentTime); // C5
    oscillator1.frequency.setValueAtTime(659.25, window.audioContext.currentTime + 0.2); // E5
    oscillator1.frequency.setValueAtTime(783.99, window.audioContext.currentTime + 0.4); // G5
    
    oscillator2.type = 'triangle';
    oscillator2.frequency.setValueAtTime(523.25 / 2, window.audioContext.currentTime); // C4
    oscillator2.frequency.setValueAtTime(659.25 / 2, window.audioContext.currentTime + 0.2); // E4
    oscillator2.frequency.setValueAtTime(783.99 / 2, window.audioContext.currentTime + 0.4); // G4
    
    gainNode.gain.setValueAtTime(0.3, window.audioContext.currentTime);
    gainNode.gain.exponentialRampToValueAtTime(0.01, window.audioContext.currentTime + 0.6);
    
    oscillator1.connect(gainNode);
    oscillator2.connect(gainNode);
    gainNode.connect(window.audioContext.destination);
    
    oscillator1.start();
    oscillator2.start();
    oscillator1.stop(window.audioContext.currentTime + 0.6);
    oscillator2.stop(window.audioContext.currentTime + 0.6);
}

// Create button click sound
function createButtonClickSound() {
    if (!window.audioContext) return;
    
    const oscillator = window.audioContext.createOscillator();
    const gainNode = window.audioContext.createGain();
    
    oscillator.type = 'sine';
    oscillator.frequency.value = 660;
    
    gainNode.gain.setValueAtTime(0.2, window.audioContext.currentTime);
    gainNode.gain.exponentialRampToValueAtTime(0.01, window.audioContext.currentTime + 0.1);
    
    oscillator.connect(gainNode);
    gainNode.connect(window.audioContext.destination);
    
    oscillator.start();
    oscillator.stop(window.audioContext.currentTime + 0.1);
}

// Create game over sound
function createGameOverSound() {
    if (!window.audioContext) return;
    
    const oscillator = window.audioContext.createOscillator();
    const gainNode = window.audioContext.createGain();
    
    oscillator.type = 'sawtooth';
    oscillator.frequency.setValueAtTime(220, window.audioContext.currentTime);
    oscillator.frequency.linearRampToValueAtTime(110, window.audioContext.currentTime + 0.3);
    oscillator.frequency.setValueAtTime(180, window.audioContext.currentTime + 0.4);
    oscillator.frequency.linearRampToValueAtTime(90, window.audioContext.currentTime + 0.7);
    
    gainNode.gain.setValueAtTime(0.3, window.audioContext.currentTime);
    gainNode.gain.linearRampToValueAtTime(0.4, window.audioContext.currentTime + 0.3);
    gainNode.gain.linearRampToValueAtTime(0.3, window.audioContext.currentTime + 0.4);
    gainNode.gain.exponentialRampToValueAtTime(0.01, window.audioContext.currentTime + 0.7);
    
    oscillator.connect(gainNode);
    gainNode.connect(window.audioContext.destination);
    
    oscillator.start();
    oscillator.stop(window.audioContext.currentTime + 0.7);
}

// Create achievement sound
function createAchievementSound() {
    if (!window.audioContext) return;
    
    const oscillator1 = window.audioContext.createOscillator();
    const oscillator2 = window.audioContext.createOscillator();
    const gainNode = window.audioContext.createGain();
    
    oscillator1.type = 'sine';
    oscillator1.frequency.setValueAtTime(587.33, window.audioContext.currentTime); // D5
    oscillator1.frequency.setValueAtTime(783.99, window.audioContext.currentTime + 0.15); // G5
    oscillator1.frequency.setValueAtTime(1046.50, window.audioContext.currentTime + 0.3); // C6
    
    oscillator2.type = 'triangle';
    oscillator2.frequency.setValueAtTime(587.33 / 2, window.audioContext.currentTime); // D4
    oscillator2.frequency.setValueAtTime(783.99 / 2, window.audioContext.currentTime + 0.15); // G4
    oscillator2.frequency.setValueAtTime(1046.50 / 2, window.audioContext.currentTime + 0.3); // C5
    
    gainNode.gain.setValueAtTime(0.2, window.audioContext.currentTime);
    gainNode.gain.linearRampToValueAtTime(0.3, window.audioContext.currentTime + 0.3);
    gainNode.gain.exponentialRampToValueAtTime(0.01, window.audioContext.currentTime + 0.5);
    
    oscillator1.connect(gainNode);
    oscillator2.connect(gainNode);
    gainNode.connect(window.audioContext.destination);
    
    oscillator1.start();
    oscillator2.start();
    oscillator1.stop(window.audioContext.currentTime + 0.5);
    oscillator2.stop(window.audioContext.currentTime + 0.5);
}

// Toggle music
function toggleMusic() {
    musicEnabled = !musicEnabled;
    const musicBtn = document.getElementById('musicToggle');

    if (musicEnabled) {
        musicBtn.classList.remove('muted');
        playBackgroundMusic();
    } else {
        musicBtn.classList.add('muted');
        if (backgroundMusic && backgroundMusic.oscillator) {
            try {
                backgroundMusic.oscillator.stop();
                backgroundMusic.gain.disconnect();
            } catch(e) {
                console.error("Error stopping background music:", e);
            }
        }
    }

    playSoundEffect('button_click');
}

// Toggle sound effects
function toggleSoundEffects() {
    soundEnabled = !soundEnabled;
    const sfxBtn = document.getElementById('sfxToggle');

    if (soundEnabled) {
        sfxBtn.classList.remove('muted');
        playSoundEffect('button_click');
    } else {
        sfxBtn.classList.add('muted');
    }
}

// Add audio context resume function on user interaction
function resumeAudioContext() {
    if (window.audioContext && window.audioContext.state === 'suspended') {
        window.audioContext.resume().then(() => {
            console.log('AudioContext resumed');
        });
    }
}

// Add event listeners to resume audio context on interaction
document.addEventListener('click', resumeAudioContext);
document.addEventListener('keydown', resumeAudioContext);
document.addEventListener('touchstart', resumeAudioContext);
    
        // Toggle FPS display
        function toggleFpsDisplay() {
            showFps = document.getElementById('showFpsCheckbox').checked;
            saveGameData();
        }
    
        // Change difficulty
        function changeDifficulty() {
            difficulty = document.getElementById('difficultySelect').value;
            saveGameData();
            showNotification("Difficulty changed to " + difficulty);
            playSoundEffect('button_click');
        }
    
        // Change grid size
        function changeGridSize() {
            baseGridSize = parseInt(document.getElementById('gridSizeSelect').value);
            saveGameData();
            showNotification("Grid size set to " + baseGridSize + "x" + baseGridSize);
            playSoundEffect('button_click');
        }
        
        // Change visual effects level
        function changeVisualEffects() {
            visualEffectsLevel = document.getElementById('visualEffectsSelect').value;
            saveGameData();
            
            // Update weather effects if active
            if (currentWeather && currentWeather.visualEffect) {
                setWeatherEffect(currentWeather.visualEffect);
            }
            
            showNotification("Visual effects set to " + visualEffectsLevel);
            playSoundEffect('button_click');
        }
    
        // Take screenshot
        function takeScreenshot() {
            // In a real implementation, this would capture the canvas and allow sharing
            toggleSocialMenu();
            showNotification("Screenshot captured!");
            playSoundEffect('button_click');
        }
    
        // Share planet seed
        function sharePlanetSeed() {
            // Create a "share" link with the seed
            const shareUrl = `${window.location.href.split('?')[0]}?seed=${planetSeed}&planet=${currentPlanet.name}`;
    
            // In a real implementation, this would use the Web Share API or copy to clipboard
            navigator.clipboard.writeText(shareUrl).then(() => {
                showNotification("Planet seed copied to clipboard!");
            });
    
            toggleSocialMenu();
            playSoundEffect('button_click');
        }
    
        // Share score
        function shareScore() {
            const shareText = `I scored ${totalScore} points exploring ${planetsExplored} planets in Cosmic Swarm: Awakening!`;
    
            // In a real implementation, this would use the Web Share API or copy to clipboard
            navigator.clipboard.writeText(shareText).then(() => {
                showNotification("Score copied to clipboard!");
            });
    
            toggleSocialMenu();
            playSoundEffect('button_click');
        }
        
        // Export save data to clipboard
        function exportSaveDataToClipboard() {
            const saveData = exportSaveData();
            if (saveData) {
                navigator.clipboard.writeText(saveData).then(() => {
                    showNotification("Save data copied to clipboard!");
                });
            } else {
                showNotification("No save data to export!");
            }
            
            toggleSocialMenu();
            playSoundEffect('button_click');
        }
        
        // Import save data from clipboard
        function importSaveDataFromClipboard() {
            navigator.clipboard.readText().then(text => {
                if (text && text.length > 0) {
                    const success = importSaveData(text);
                    if (success) {
                        // Update UI with loaded data
                        updateGameDataDisplay();
                    }
                } else {
                    showNotification("No data in clipboard!");
                }
            }).catch(err => {
                showNotification("Error accessing clipboard!");
                console.error("Clipboard error:", err);
            });
            
            toggleSocialMenu();
            playSoundEffect('button_click');
        }
    
        // Toggle settings menu
        function toggleSettingsMenu() {
            const menu = document.getElementById('settings-menu');
            menu.classList.toggle('active');
    
            // Hide other menus if open
            document.getElementById('social-menu').classList.remove('active');
            document.getElementById('drones-menu').classList.remove('active');
    
            playSoundEffect('button_click');
        }
    
        // Toggle social menu
        function toggleSocialMenu() {
            const menu = document.getElementById('social-menu');
            menu.classList.toggle('active');
    
            // Hide other menus if open
            document.getElementById('settings-menu').classList.remove('active');
            document.getElementById('drones-menu').classList.remove('active');
    
            playSoundEffect('button_click');
        }
        
        // Show achievements overlay
        function showAchievementsOverlay() {
            // Create an overlay to display all achievements
            const overlay = document.createElement('div');
            overlay.style.position = 'fixed';
            overlay.style.top = '0';
            overlay.style.left = '0';
            overlay.style.width = '100%';
            overlay.style.height = '100%';
            overlay.style.backgroundColor = 'rgba(0, 0, 0, 0.85)';
            overlay.style.display = 'flex';
            overlay.style.justifyContent = 'center';
            overlay.style.alignItems = 'center';
            overlay.style.zIndex = '1000';
            overlay.style.backdropFilter = 'blur(3px)';
            
            const modal = document.createElement('div');
            modal.className = 'modal fade-in';
            modal.style.width = '80%';
            modal.style.maxWidth = '800px';
            modal.style.maxHeight = '80vh';
            modal.style.overflow = 'auto';
            
            modal.innerHTML = `
                <h2>Achievements</h2>
                <div id="achievements-grid" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(180px, 1fr)); gap: 1rem; margin: 1rem 0;">
                    ${ACHIEVEMENTS.map(achievement => `
                        <div class="achievement-card" style="background-color: rgba(30, 40, 60, 0.7); border-radius: 8px; padding: 1rem; border: 1px solid ${achievement.unlocked ? '#4af' : '#555'};">
                            <div style="display: flex; align-items: center; margin-bottom: 0.5rem;">
                                <div style="width: 40px; height: 40px; border-radius: 50%; background-color: ${achievement.unlocked ? '#26c' : '#333'}; display: flex; align-items: center; justify-content: center; margin-right: 0.5rem; font-size: 1.2rem;">${achievement.icon}</div>
                                <div style="font-weight: bold; color: ${achievement.unlocked ? '#4af' : '#aaa'};">${achievement.name}</div>
                            </div>
                            <div style="font-size: 0.9rem; margin-bottom: 0.5rem;">${achievement.description}</div>
                            <div style="font-size: 0.8rem; color: #acd;">Bonus: +${achievement.bonus} points</div>
                            <div style="height: 4px; background-color: rgba(64, 170, 255, 0.2); border-radius: 2px; margin-top: 0.5rem;">
                                <div style="height: 100%; background-color: ${achievement.unlocked ? '#4af' : '#666'}; border-radius: 2px; width: ${achievement.unlocked ? '100' : Math.min(100, Math.floor((achievement.progress.current / achievement.progress.target) * 100))}%;"></div>
                            </div>
                            <div style="font-size: 0.8rem; text-align: right; margin-top: 0.2rem; color: ${achievement.unlocked ? '#4af' : '#aaa'};">${achievement.unlocked ? 'Complete!' : `${achievement.progress.current}/${achievement.progress.target}`}</div>
                        </div>
                    `).join('')}
                </div>
                <button class="big-btn" id="close-achievements-btn">Close</button>
            `;
            
            overlay.appendChild(modal);
            document.body.appendChild(overlay);
            
            document.getElementById('close-achievements-btn').addEventListener('click', () => {
                document.body.removeChild(overlay);
                playSoundEffect('button_click');
            });
            
            playSoundEffect('button_click');
        }
    
        // Show notification
        function showNotification(message) {
            // Remove existing notification if present
            const existingNotification = document.querySelector('.upgrade-notification');
            if (existingNotification) {
                existingNotification.remove();
            }
    
            // Clear timeout if exists
            if (notificationTimeout) {
                clearTimeout(notificationTimeout);
            }
    
            // Create notification element
            const notification = document.createElement('div');
            notification.className = 'upgrade-notification';
            notification.textContent = message;
            document.body.appendChild(notification);
    
            // Remove after 5 seconds
            notificationTimeout = setTimeout(() => {
                notification.remove();
                notificationTimeout = null;
            }, 5000);
        }
    
        function adjustCanvasSize() {
            // For mobile, make canvas square and fit to screen width
            if (window.innerWidth < 768) {
                const maxWidth = Math.min(window.innerWidth - 20, 400);
                canvas.width = maxWidth;
                canvas.height = maxWidth;
            } else {
                // On desktop, use default size
                canvas.width = 400;
                canvas.height = 400;
            }
    
            // Recalculate tile size based on new dimensions
            tileSize = canvas.width / gridSize;
    
            // Redraw
            drawGrid();
        }
    
        function handleTouchMove(event) {
            event.preventDefault();
            if (event.touches.length > 0) {
                const touch = event.touches[0];
                const rect = canvas.getBoundingClientRect();
                handleTooltipMovement(touch.clientX - rect.left, touch.clientY - rect.top);
            }
        }
    
        function startNewMission(startActive = true) {
            // Use the seed parameter if provided in URL
            const urlParams = new URLSearchParams(window.location.search);
            if (urlParams.has('seed')) {
                planetSeed = parseInt(urlParams.get('seed'));
            } else {
                // Generate a new random seed
                planetSeed = Math.floor(Math.random() * 1000000);
            }
    
            // Set up pseudo-random generation based on seed
            Math.seedrandom = function(seed) {
                let m = 0x80000000;
                let a = 1103515245;
                let c = 12345;
                let state = seed;
    
                return function() {
                    state = (a * state + c) % m;
                    return state / m;
                };
            };
    
            // Initialize seeded random function
            const seededRandom = Math.seedrandom(planetSeed);
    
            // Reset robot state
            robot.energy = robot.maxEnergy;
            robot.minerals = 0;
            robot.crystals = 0;
            robot.exotic = 0;
            robot.hasBase = false;
            robot.shipConstructed = false;
            robot.statusEffects = [];
            robot.baseLocation = null;
            robot.busy = false;
            robot.actionTimeRemaining = 0;
            robot.actionMaxTime = 0;
            robot.actionProgress = 0;
            robot.currentAction = null;
            robot.actionCompletionFunction = null;
            robot.revealedTiles = 0;
            robot.scannedTiles = 0;
            robot.actionsPerformed = 0;
            robot.missionScore = 0;
            robot.lastAction = null;
    
            // Clear any active timer
            if (robot.actionTimer) {
                clearInterval(robot.actionTimer);
                robot.actionTimer = null;
            }
    
            // Reset active missions
            activeSideMissions = [];
            activeAnomalies = [];
            specialMission = null;
    
            // Reset deployed drones
            deployedDrones = deployedDrones.map(drone => ({
                ...drone,
                cooldownRemaining: 0
            }));
    
            // Apply upgrades to robot stats
            applyUpgrades();
            
            // Apply relic effects
            applyRelicEffects();
    
            // Determine planet type (based on mission progression or random for seeded planets)
            let planetTypeIndex;
            if (urlParams.has('seed')) {
                planetTypeIndex = Math.floor(seededRandom() * PLANET_TYPES.length);
            } else {
                planetTypeIndex = (missionNumber - 1) % PLANET_TYPES.length;
            }
    
            currentPlanet.type = PLANET_TYPES[planetTypeIndex];
            currentPlanet.icon = currentPlanet.type.icon;
    
            // Use name from URL or random name
            if (urlParams.has('planet')) {
                currentPlanet.name = urlParams.get('planet');
            } else {
                currentPlanet.name = PLANET_NAMES[Math.floor(seededRandom() * PLANET_NAMES.length)];
            }
    
            currentPlanet.color = currentPlanet.type.color;
    
            // Update grid size based on mission number and difficulty (increasing difficulty)
            if (startActive) {
                // Use the baseGridSize from settings
                let difficultyModifier = 0;
                if (difficulty === "easy") difficultyModifier = -1;
                if (difficulty === "hard") difficultyModifier = 1;
                if (difficulty === "extreme") difficultyModifier = 2;
    
                gridSize = Math.min(10, baseGridSize + Math.floor(missionNumber / 3) + difficultyModifier);
            } else {
                gridSize = baseGridSize;
            }
    
            tileSize = canvas.width / gridSize;
    
            // Generate new grid
            generateGrid(seededRandom);
    
            // Place robot at a random valid position
            placeRobotRandomly(seededRandom);
    
            // Make sure the starting tile is revealed
            revealTile(robot.x, robot.y);
    
            // Initialize mission weather
            initializeWeather();
    
            // Add anomalies and side missions
            if (startActive) {
                // Add 1-3 anomalies to the map based on difficulty
                let anomalyCount = 1;
                if (difficulty === "normal") anomalyCount = 2;
                if (difficulty === "hard" || difficulty === "extreme") anomalyCount = 3;
                
                for (let i = 0; i < anomalyCount; i++) {
                    addAnomaly(seededRandom);
                }
    
                // 70% chance to add a side mission
                if (seededRandom() < 0.7) {
                    generateSideMission();
                }
    
                // 40% chance to add a special mission
                if (seededRandom() < 0.4) {
                    generateSpecialMission();
                }
                
                // 15% chance to add a relic if player level is high enough
                if (seededRandom() < 0.15 && currentLevel >= 5) {
                    addRelicToMap(seededRandom);
                }
            }
    
            // Update UI
            document.getElementById('planetName').textContent = currentPlanet.name;
            document.getElementById('planetIcon').textContent = currentPlanet.icon;
            document.getElementById('planetType').textContent = currentPlanet.type.name;
            document.getElementById('missionCounter').textContent = missionNumber;
            document.getElementById('sideMissions').innerHTML = '<div><strong>SIDE MISSIONS:</strong></div><div id="noMissions">No active side missions</div>';
            document.getElementById('maxEnergy').textContent = robot.maxEnergy;
    
            // Clear log
            const missionLog = document.getElementById('missionLog');
            missionLog.innerHTML = '';
            addLogEntry(`Robot ${missionNumber} deployed to ${currentPlanet.name} (${currentPlanet.type.name})`);
            addLogEntry('Primary mission: Establish base and launch exploration ship');
            addLogEntry(`Planet description: ${currentPlanet.type.description}`);
    
            // Update drone display
            updateDroneDisplay();
    
            // Update objective display
            updateObjectiveDisplay();
    
            // Initial draw
            updateUI();
            drawGrid();
            
            // Achievement tracking for special planets
            if (currentPlanet.type.name === "Quantum Flux Plains") {
                updateAchievementProgress("quantum_theorist", 1);
            }
        }
        
        // Add a relic to the map
        function addRelicToMap(seededRandom) {
            // Find undiscovered relics
            const undiscoveredRelics = RELICS.filter(relic => !relic.discovered);
            if (undiscoveredRelics.length === 0) return;
            
            // Select a random undiscovered relic
            const relicToAdd = undiscoveredRelics[Math.floor(seededRandom() * undiscoveredRelics.length)];
            
            // Find a suitable location for the relic
            const validTiles = [];
            for (let y = 0; y < gridSize; y++) {
                for (let x = 0; x < gridSize; x++) {
                    if (grid[y][x].type === 'empty' && 
                        !(x === robot.x && y === robot.y) &&
                        !grid[y][x].isAnomaly &&
                        !grid[y][x].isRelic) {
                        validTiles.push({ x, y });
                    }
                }
            }
            
            if (validTiles.length > 0) {
                const randomIndex = Math.floor(seededRandom() * validTiles.length);
                const relicPos = validTiles[randomIndex];
                
                // Mark tile as containing a relic
                grid[relicPos.y][relicPos.x].isRelic = true;
                grid[relicPos.y][relicPos.x].relicId = relicToAdd.id;
                
                addLogEntry("Scans indicate a possible ancient artifact on this planet.");
            }
        }
        
        // Apply relic effects
        function applyRelicEffects() {
            // Reset passive effects first
            robot.passive_energy_regen = 0;
            
            // Apply each discovered relic's effect
            for (const relic of discoveredRelics) {
                if (relic.effect.type === "energy_regen") {
                    robot.passive_energy_regen += relic.effect.value;
                }
                // Other effects will be applied dynamically when needed
            }
        }
    
        // Initialize weather for the current mission
        function initializeWeather() {
            // Clear existing weather timers
            if (weatherTimer) {
                clearInterval(weatherTimer);
            }
    
            // Select initial weather
            updatePlanetWeather();
    
            // Set up weather change timer (every 30-60 seconds)
            weatherTimer = setInterval(() => {
                if (gameActive) {
                    updatePlanetWeather();
                }
            }, 30000 + Math.random() * 30000);
        }
    
        // Update planet weather
        function updatePlanetWeather() {
            // Select weather based on chances
            let totalChance = 0;
            for (const weather of WEATHER_TYPES) {
                totalChance += weather.chance;
            }
    
            let random = Math.random() * totalChance;
            let cumulativeChance = 0;
    
            for (const weather of WEATHER_TYPES) {
                cumulativeChance += weather.chance;
                if (random <= cumulativeChance) {
                    currentWeather = weather;
                    break;
                }
            }
    
            // Update weather display
            document.getElementById('weatherDisplay').textContent = 
                `Weather: ${currentWeather.name}`;
    
            // Apply visual effect
            setWeatherEffect(currentWeather.visualEffect);
    
            // Update robot status effects
            if (currentWeather.effect) {
                // Check for existing weather effect
                const existingWeatherEffect = robot.statusEffects.findIndex(
                    effect => effect.source === 'weather'
                );
    
                if (existingWeatherEffect !== -1) {
                    robot.statusEffects.splice(existingWeatherEffect, 1);
                }
                
                // Apply weather resistance from relics if applicable
                let effectValue = currentWeather.effect.value;
                
                // Check for weather control relic
                const weatherRelic = discoveredRelics.find(r => r.effect.type === "weather_control");
                if (weatherRelic) {
                    // Check if positive or negative effect
                    if (currentWeather.effect.type === "energy_boost" || currentWeather.effect.type === "crystal_boost" || currentWeather.effect.type === "exotic_boost") {
                        // Positive effect, amplify
                        effectValue *= weatherRelic.effect.positive_value;
                    } else {
                        // Negative effect, reduce
                        if (currentWeather.effect.type === "energy_drain") {
                            effectValue *= weatherRelic.effect.negative_value;
                        } else {
                            effectValue = 1 - (1 - effectValue) * weatherRelic.effect.negative_value;
                        }
                    }
                }
                
                // Check for weather resistance from tech
                const weatherTech = TECH_TREE.find(t => t.id === "weather_systems" && t.unlocked);
                if (weatherTech) {
                    // Check if positive or negative effect
                    if (currentWeather.effect.type === "energy_boost" || currentWeather.effect.type === "crystal_boost" || currentWeather.effect.type === "exotic_boost") {
                        // Apply boost from tech effect
                        const boostEffect = weatherTech.effects.find(e => e.type === "weather_boost");
                        if (boostEffect) {
                            effectValue *= boostEffect.value;
                        }
                    } else {
                        // Apply resistance from tech effect
                        const resistanceEffect = weatherTech.effects.find(e => e.type === "weather_resistance");
                        if (resistanceEffect) {
                            if (currentWeather.effect.type === "energy_drain") {
                                effectValue *= resistanceEffect.value;
                            } else {
                                effectValue = 1 - (1 - effectValue) * resistanceEffect.value;
                            }
                        }
                    }
                }
    
                // Add new weather effect with modified value
                robot.statusEffects.push({
                    name: currentWeather.name,
                    effect: { 
                        type: currentWeather.effect.type, 
                        value: effectValue 
                    },
                    duration: 'Permanent',
                    source: 'weather'
                });
            } else {
                // Remove any weather status effects
                robot.statusEffects = robot.statusEffects.filter(
                    effect => effect.source !== 'weather'
                );
            }
    
            // Update UI
            updateUI();
    
            // Log the weather change
            addLogEntry(`Weather changed to ${currentWeather.name}: ${currentWeather.description}`);
            
            // Check for weather-related side missions
            checkSideMissionProgress("weather_change");
        }
    
        // Add anomaly to the map
        function addAnomaly(seededRandom) {
            // Find a suitable location for the anomaly
            const validTiles = [];
    
            for (let y = 0; y < gridSize; y++) {
                for (let x = 0; x < gridSize; x++) {
                    if (grid[y][x].type === 'empty' && 
                        !(x === robot.x && y === robot.y) &&
                        !grid[y][x].isAnomaly) {
                        validTiles.push({ x, y });
                    }
                }
            }
    
            if (validTiles.length > 0) {
                const randomIndex = Math.floor(seededRandom() * validTiles.length);
                const anomalyPos = validTiles[randomIndex];
    
                // Mark tile as containing an anomaly
                grid[anomalyPos.y][anomalyPos.x].isAnomaly = true;
    
                // Create the anomaly data
                const eventIndex = Math.floor(seededRandom() * SPECIAL_EVENTS.length);
                const anomaly = {
                    x: anomalyPos.x,
                    y: anomalyPos.y,
                    discovered: false,
                    eventData: SPECIAL_EVENTS[eventIndex]
                };
    
                activeAnomalies.push(anomaly);
    
                // Update any side missions that require finding anomalies
                for (const mission of activeSideMissions) {
                    if (mission.parameters.type === 'anomaly' && mission.parameters.locationX === null) {
                        mission.parameters.locationX = anomalyPos.x;
                        mission.parameters.locationY = anomalyPos.y;
                    }
                }
            }
        }
    
        // Generate a side mission
        function generateSideMission() {
            const missionIndex = Math.floor(Math.random() * SIDE_MISSIONS.length);
            const missionTemplate = SIDE_MISSIONS[missionIndex];
    
            const mission = {
                name: missionTemplate.name,
                description: missionTemplate.description,
                parameters: missionTemplate.generateParameters(),
                reward: missionTemplate.reward,
                completed: false
            };
    
            // Format the description with parameter values
            mission.description = mission.description.replace('{target}', mission.parameters.target);
    
            if (mission.parameters.resourceType) {
                mission.description = mission.description.replace('{resourceType}', mission.parameters.resourceType);
            }
    
            // If it's an anomaly mission, we need to assign a location
            if (mission.parameters.type === 'anomaly' && activeAnomalies.length > 0) {
                const anomaly = activeAnomalies[0];
                mission.parameters.locationX = anomaly.x;
                mission.parameters.locationY = anomaly.y;
            }
    
            // Show the side mission offer
            showSideMissionOffer(mission);
        }
    
        // Show side mission offer
        function showSideMissionOffer(mission) {
            document.getElementById('sideMissionTitle').textContent = mission.name;
            document.getElementById('sideMissionContent').textContent = mission.description;
    
            // Format reward display
            let rewardText = "";
            if (mission.reward.score) {
                rewardText += `${mission.reward.score} score points`;
            }
    
            if (mission.reward.resources) {
                if (rewardText) rewardText += ", ";
    
                for (const [resource, amount] of Object.entries(mission.reward.resources)) {
                    let icon = "";
                    if (resource === "energy") icon = "‚ö°";
                    else if (resource === "minerals") icon = "üî∑";
                    else if (resource === "crystals") icon = "üíé";
                    else if (resource === "exotic") icon = "üß™";
    
                    rewardText += `${amount} ${icon} ${resource}`;
                }
            }
    
            if (mission.reward.upgrade) {
                if (rewardText) rewardText += ", ";
                rewardText += "Permanent upgrade";
            }
            
            if (mission.reward.techPoints) {
                if (rewardText) rewardText += ", ";
                rewardText += `${mission.reward.techPoints} tech point${mission.reward.techPoints > 1 ? 's' : ''}`;
            }
            
            if (mission.reward.xp) {
                if (rewardText) rewardText += ", ";
                rewardText += `${mission.reward.xp} XP`;
            }
    
            document.getElementById('sideMissionReward').textContent = rewardText;
    
            // Store the mission temporarily
            window.pendingSideMission = mission;
    
            // Show the overlay
            document.getElementById('side-mission-overlay').style.display = 'flex';
    
            // Play sound effect
            playSoundEffect('discovery');
        }
    
        // Accept side mission
        function acceptSideMission() {
            if (window.pendingSideMission) {
                activeSideMissions.push(window.pendingSideMission);
                window.pendingSideMission = null;
    
                // Hide the overlay
                document.getElementById('side-mission-overlay').style.display = 'none';
    
                // Update side missions display
                updateSideMissionsDisplay();
    
                // Log the acceptance
                addLogEntry(`Accepted side mission: ${activeSideMissions[activeSideMissions.length - 1].name}`);
    
                // Play sound effect
                playSoundEffect('button_click');
            }
        }
    
        // Decline side mission
        function declineSideMission() {
            window.pendingSideMission = null;
    
            // Hide the overlay
            document.getElementById('side-mission-overlay').style.display = 'none';
    
            // Play sound effect
            playSoundEffect('button_click');
        }
    
        // Update side missions display
        function updateSideMissionsDisplay() {
            const container = document.getElementById('sideMissions');
            container.innerHTML = '<div><strong>SIDE MISSIONS:</strong></div>';
    
            if (activeSideMissions.length === 0) {
                const noMissions = document.createElement('div');
                noMissions.id = 'noMissions';
                noMissions.textContent = 'No active side missions';
                container.appendChild(noMissions);
                return;
            }
    
            for (const mission of activeSideMissions) {
                const missionElement = document.createElement('div');
                missionElement.className = 'side-mission';
    
                // Create mission description with progress
                let missionText = mission.name + ": ";
    
                if (mission.parameters.type === 'scan' || mission.parameters.type === 'collect' || mission.parameters.type === 'weather_survival') {
                    missionText += `${mission.parameters.current}/${mission.parameters.target} `;
                }
                
                if (mission.parameters.type === 'map_reveal') {
                    const revealedPercentage = Math.floor((robot.revealedTiles / (gridSize * gridSize)) * 100);
                    missionText += `${revealedPercentage}%/${mission.parameters.target}% `;
                }
    
                missionText += mission.description;
    
                missionElement.textContent = missionText;
                container.appendChild(missionElement);
            }
        }
    
        // Generate a special mission
        function generateSpecialMission() {
            // Different types of special missions
            const specialMissionTypes = [
                {
                    name: "Strange Signal",
                    description: "Investigate a mysterious signal at the center of the planet",
                    generateFunction: () => {
                        // Place an objective at center of map
                        const centerX = Math.floor(gridSize / 2);
                        const centerY = Math.floor(gridSize / 2);
    
                        return {
                            type: "investigate",
                            target: { x: centerX, y: centerY },
                            completed: false,
                            reward: {
                                score: 300,
                                upgrade: "scanner_range",
                                xp: 40
                            }
                        };
                    }
                },
                {
                    name: "Resource Cache",
                    description: "Find and secure valuable resources hidden on the planet",
                    generateFunction: () => {
                        // Place resources in corners
                        const cacheLocations = [
                            { x: 0, y: 0 },
                            { x: gridSize - 1, y: 0 },
                            { x: 0, y: gridSize - 1 },
                            { x: gridSize - 1, y: gridSize - 1 }
                        ];
    
                        // Choose a random corner
                        const locationIndex = Math.floor(Math.random() * cacheLocations.length);
    
                        return {
                            type: "collect_cache",
                            target: cacheLocations[locationIndex],
                            completed: false,
                            reward: {
                                resources: { minerals: 5, crystals: 3, exotic: 1 },
                                score: 250,
                                xp: 35
                            }
                        };
                    }
                },
                {
                    name: "Energy Efficiency",
                    description: "Complete the mission using less than 50 energy",
                    generateFunction: () => {
                        return {
                            type: "efficiency",
                            maxEnergy: 50,
                            completed: false,
                            reward: {
                                upgrade: "energy_efficiency",
                                score: 200,
                                xp: 30
                            }
                        };
                    }
                },
                {
                    name: "Ancient Archive",
                    description: "Access a data archive from an advanced civilization",
                    generateFunction: () => {
                        // Place in a random location that's not too close to the start
                        let x, y;
                        do {
                            x = Math.floor(Math.random() * gridSize);
                            y = Math.floor(Math.random() * gridSize);
                        } while (Math.abs(x - robot.x) < 3 && Math.abs(y - robot.y) < 3);
                        
                        return {
                            type: "access_archive",
                            target: { x, y },
                            completed: false,
                            reward: {
                                techPoints: 1,
                                score: 350,
                                xp: 45
                            }
                        };
                    }
                },
                {
                    name: "Quantum Stabilization",
                    description: "Stabilize quantum fluctuations at three key points on the planet",
                    generateFunction: () => {
                        // Generate three points in different quadrants
                        const points = [];
                        const halfGrid = Math.floor(gridSize / 2);
                        
                        // Top-left quadrant
                        points.push({
                            x: Math.floor(Math.random() * halfGrid),
                            y: Math.floor(Math.random() * halfGrid)
                        });
                        
                        // Top-right quadrant
                        points.push({
                            x: halfGrid + Math.floor(Math.random() * halfGrid),
                            y: Math.floor(Math.random() * halfGrid)
                        });
                        
                        // Bottom-left quadrant
                        points.push({
                            x: Math.floor(Math.random() * halfGrid),
                            y: halfGrid + Math.floor(Math.random() * halfGrid)
                        });
                        
                        return {
                            type: "stabilize_points",
                            targets: points,
                            currentTarget: 0,
                            completed: false,
                            reward: {
                                upgrade: "quantum_stabilizer",
                                score: 400,
                                xp: 50
                            }
                        };
                    }
                }
            ];
    
            // Choose a random special mission
            const missionIndex = Math.floor(Math.random() * specialMissionTypes.length);
            const missionTemplate = specialMissionTypes[missionIndex];
    
            specialMission = {
                name: missionTemplate.name,
                description: missionTemplate.description,
                parameters: missionTemplate.generateFunction(),
            };
    
            // Update display
            updateSpecialMissionDisplay();
    
            // Announce the mission
            addLogEntry(`Special mission detected: ${specialMission.name}`);
        }
    
        // Update special mission display
        function updateSpecialMissionDisplay() {
            const specialMissionElement = document.getElementById('specialMission');
    
            if (!specialMission) {
                specialMissionElement.style.display = 'none';
                return;
            }
    
            specialMissionElement.style.display = 'block';
    
            // Set mission text
            document.getElementById('specialMissionText').textContent = 
                `${specialMission.name}: ${specialMission.description}`;
    
            // Update progress bar if applicable
            if (specialMission.parameters.type === "efficiency") {
                const progress = Math.max(0, 100 - (robot.energy * 100 / specialMission.parameters.maxEnergy));
                document.getElementById('specialMissionBar').style.width = `${progress}%`;
            } else if (specialMission.parameters.type === "stabilize_points") {
                const totalPoints = specialMission.parameters.targets.length;
                const progress = (specialMission.parameters.currentTarget / totalPoints) * 100;
                document.getElementById('specialMissionBar').style.width = `${progress}%`;
            } else {
                document.getElementById('specialMissionBar').style.width = 
                    specialMission.parameters.completed ? "100%" : "0%";
            }
        }
    
        // Check special mission progress
        function checkSpecialMissionProgress() {
            if (!specialMission) return;
    
            if (specialMission.parameters.type === "investigate") {
                // Check if robot is at target location
                if (robot.x === specialMission.parameters.target.x && 
                    robot.y === specialMission.parameters.target.y) {
    
                    // Complete the mission
                    specialMission.parameters.completed = true;
                    completeSpecialMission();
                }
            } else if (specialMission.parameters.type === "collect_cache") {
                // Check if robot is at cache location
                if (robot.x === specialMission.parameters.target.x && 
                    robot.y === specialMission.parameters.target.y) {
    
                    // Complete the mission
                    specialMission.parameters.completed = true;
                    completeSpecialMission();
                }
            } else if (specialMission.parameters.type === "efficiency") {
                // This will be checked at mission completion
                updateSpecialMissionDisplay();
            } else if (specialMission.parameters.type === "access_archive") {
                // Check if robot is at archive location
                if (robot.x === specialMission.parameters.target.x && 
                    robot.y === specialMission.parameters.target.y) {
    
                    // Complete the mission
                    specialMission.parameters.completed = true;
                    completeSpecialMission();
                }
            } else if (specialMission.parameters.type === "stabilize_points") {
                // Check if robot is at current target location
                const currentTarget = specialMission.parameters.targets[specialMission.parameters.currentTarget];
                if (robot.x === currentTarget.x && robot.y === currentTarget.y) {
                    // Move to next target
                    specialMission.parameters.currentTarget++;
                    
                    // Update progress display
                    updateSpecialMissionDisplay();
                    
                    addLogEntry(`Point stabilized! ${specialMission.parameters.currentTarget}/${specialMission.parameters.targets.length} complete.`);
                    
                    // Check if all targets are stabilized
                    if (specialMission.parameters.currentTarget >= specialMission.parameters.targets.length) {
                        specialMission.parameters.completed = true;
                        completeSpecialMission();
                    }
                }
            }
        }
    
        // Complete special mission
        function completeSpecialMission() {
            // Add rewards
            if (specialMission.parameters.reward) {
                const reward = specialMission.parameters.reward;
    
                // Add score
                if (reward.score) {
                    robot.missionScore += reward.score;
                    addLogEntry(`Special mission completed! +${reward.score} points`);
                }
    
                // Add resources
                if (reward.resources) {
                    for (const [resource, amount] of Object.entries(reward.resources)) {
                        if (resource === "minerals") robot.minerals += amount;
                        else if (resource === "crystals") robot.crystals += amount;
                        else if (resource === "exotic") robot.exotic += amount;
                        else if (resource === "energy") robot.energy = Math.min(robot.maxEnergy, robot.energy + amount);
                    }
    
                    addLogEntry('Received resources as reward!');
                }
    
                // Add upgrade
                if (reward.upgrade) {
                    addUpgrade(reward.upgrade);
                }
                
                // Add tech points
                if (reward.techPoints) {
                    techPoints += reward.techPoints;
                    addLogEntry(`Gained ${reward.techPoints} tech point${reward.techPoints > 1 ? 's' : ''}!`);
                }
                
                // Add XP
                if (reward.xp) {
                    const xpGained = addExperience(reward.xp);
                    addLogEntry(`Gained ${xpGained} XP!`);
                }
            }
    
            // Update display
            updateSpecialMissionDisplay();
            updateGameDataDisplay();
    
            // Show notification
            showNotification(`Special mission "${specialMission.name}" completed!`);
    
            // Play sound effect
            playSoundEffect('achievement');
        }
    
        // Apply all active upgrades to robot stats
        function applyUpgrades() {
            // Reset to base stats first
            robot.maxEnergy = 100;
    
            // Apply each upgrade
            for (const upgradeId of upgrades) {
                const upgrade = UPGRADES[upgradeId];
    
                if (upgrade) {
                    if (upgrade.effect.type === "capacity" && upgrade.effect.target === "energy") {
                        robot.maxEnergy += upgrade.effect.value;
                    }
                }
            }
            
            // Apply level-based energy bonuses
            for (let level = 2; level <= currentLevel; level += 2) {
                // Every 2 levels, add 10 energy capacity
                robot.maxEnergy += 10;
            }
            
            // Apply tech tree bonuses
            for (const tech of TECH_TREE) {
                if (tech.unlocked) {
                    for (const effect of tech.effects) {
                        if (effect.type === "capacity" && effect.target === "energy") {
                            robot.maxEnergy += effect.value;
                        }
                    }
                }
            }
    
            // Set current energy to max
            robot.energy = robot.maxEnergy;
        }
    
        // Add an upgrade
        function addUpgrade(upgradeId) {
            if (!upgrades.includes(upgradeId) && UPGRADES[upgradeId]) {
                upgrades.push(upgradeId);
    
                // Apply the upgrade immediately
                if (UPGRADES[upgradeId].effect.type === "capacity" && 
                    UPGRADES[upgradeId].effect.target === "energy") {
                    robot.maxEnergy += UPGRADES[upgradeId].effect.value;
                    robot.energy = Math.min(robot.maxEnergy, robot.energy + UPGRADES[upgradeId].effect.value);
                }
    
                // Update UI
                updateUpgradesDisplay();
    
                // Show notification
                showNotification(`Upgrade acquired: ${UPGRADES[upgradeId].name}!`);
    
                // Save game data
                saveGameData();
            }
        }
    
        // Check for upgrade effects when performing actions
        function getUpgradeEffect(type, target) {
            let effect = 1.0; // Default, no modification
    
            // Apply upgrades
            for (const upgradeId of upgrades) {
                const upgrade = UPGRADES[upgradeId];
    
                if (upgrade && upgrade.effect.type === type && 
                   (upgrade.effect.target === target || upgrade.effect.target === "all")) {
                    if (type === "efficiency") {
                        effect *= upgrade.effect.value;
                    } else if (type === "speed") {
                        effect *= upgrade.effect.value;
                    }
                }
            }
            
            // Apply technology effects
            for (const tech of TECH_TREE) {
                if (tech.unlocked) {
                    for (const techEffect of tech.effects) {
                        if (techEffect.type === type && 
                           (techEffect.target === target || techEffect.target === "all")) {
                            if (type === "efficiency") {
                                effect *= techEffect.value;
                            } else if (type === "speed") {
                                effect *= techEffect.value;
                            }
                        }
                    }
                }
            }
            
            // Apply cosmic harmonization global efficiency boost if unlocked
            const cosmicTech = TECH_TREE.find(t => t.id === "cosmic_harmonization" && t.unlocked);
            if (cosmicTech && type === "efficiency") {
                const globalBoost = cosmicTech.effects.find(e => e.type === "global_efficiency_boost");
                if (globalBoost) {
                    effect *= globalBoost.value;
                }
            }
            
            // Apply time efficiency if unlocked
            const temporalTech = TECH_TREE.find(t => t.id === "temporal_mechanics" && t.unlocked);
            if (temporalTech && type === "speed") {
                const timeEffect = temporalTech.effects.find(e => e.type === "time_efficiency");
                if (timeEffect) {
                    effect *= timeEffect.value;
                }
            }
    
            return effect;
        }
    
        // Check for bonus resources from upgrades
        function checkResourceBonus(resourceType) {
            let bonusAmount = 0;
            
            // Check upgrades
            for (const upgradeId of upgrades) {
                const upgrade = UPGRADES[upgradeId];
    
                if (upgrade && upgrade.effect.type === "bonus_chance" && 
                    upgrade.effect.target === resourceType) {
    
                    // Check if bonus triggers
                    if (Math.random() < upgrade.effect.value) {
                        bonusAmount += 1; // One extra resource
                    }
                }
            }
            
            // Check technologies
            for (const tech of TECH_TREE) {
                if (tech.unlocked) {
                    for (const effect of tech.effects) {
                        if (effect.type === "bonus_chance" && effect.target === resourceType) {
                            // Check if bonus triggers
                            if (Math.random() < effect.value) {
                                bonusAmount += 1;
                            }
                        }
                    }
                }
            }
            
            // Check relics
            for (const relic of discoveredRelics) {
                if ((relic.effect.type === "crystal_yield" && resourceType === "crystals") ||
                    (relic.effect.type === "exotic_yield" && resourceType === "exotic")) {
                    // Check if we should add additional resources
                    const extraAmount = Math.random() < 0.5 ? 1 : 0; // 50% chance for an extra unit
                    bonusAmount += extraAmount;
                }
            }
    
            return bonusAmount;
        }
    
        // Check for auto-scan from upgrades
        function checkAutoScan() {
            for (const upgradeId of upgrades) {
                const upgrade = UPGRADES[upgradeId];
    
                if (upgrade && upgrade.effect.type === "auto_scan") {
                    // Check if auto-scan triggers
                    if (Math.random() < upgrade.effect.value) {
                        // Scan adjacent tiles
                        const adjacentTiles = getAdjacentTiles(robot.x, robot.y);
    
                        for (const tile of adjacentTiles) {
                            if (!grid[tile.y][tile.x].scanned) {
                                grid[tile.y][tile.x].scanned = true;
    
                                // 20% chance to fully reveal the tile
                                if (Math.random() < 0.2) {
                                    grid[tile.y][tile.x].revealed = true;
                                }
                            }
                        }
    
                        // Show notification
                        addLogEntry("Auto-scanner activated!");
                        return true;
                    }
                }
            }
            
            // Check for deep scanning technology
            const deepScanTech = TECH_TREE.find(t => t.id === "deep_scanning" && t.unlocked);
            if (deepScanTech) {
                for (const effect of deepScanTech.effects) {
                    if (effect.type === "deep_scan") {
                        // Check if deep scan triggers
                        if (Math.random() < effect.value) {
                            // Scan nearby tiles deeper
                            const adjacentTiles = getAdjacentTiles(robot.x, robot.y);
                            
                            for (const tile of adjacentTiles) {
                                if (!grid[tile.y][tile.x].revealed) {
                                    // Deep scan always fully reveals
                                    grid[tile.y][tile.x].scanned = true;
                                    grid[tile.y][tile.x].revealed = true;
                                    robot.revealedTiles++;
                                }
                            }
                            
                            addLogEntry("Deep scanner activated, revealing nearby tiles!");
                            return true;
                        }
                    }
                }
            }
    
            return false;
        }
    
        // Get adjacent tiles
        function getAdjacentTiles(x, y) {
            const adjacent = [];
    
            // Check up
            if (y > 0) adjacent.push({ x, y: y - 1 });
    
            // Check down
            if (y < gridSize - 1) adjacent.push({ x, y: y + 1 });
    
            // Check left
            if (x > 0) adjacent.push({ x: x - 1, y });
    
            // Check right
            if (x < gridSize - 1) adjacent.push({ x: x + 1, y });
            
            // Check diagonals if enabled
            if (diagonalMovementEnabled) {
                // Check up-left
                if (y > 0 && x > 0) adjacent.push({ x: x - 1, y: y - 1 });
                
                // Check up-right
                if (y > 0 && x < gridSize - 1) adjacent.push({ x: x + 1, y: y - 1 });
                
                // Check down-left
                if (y < gridSize - 1 && x > 0) adjacent.push({ x: x - 1, y: y + 1 });
                
                // Check down-right
                if (y < gridSize - 1 && x < gridSize - 1) adjacent.push({ x: x + 1, y: y + 1 });
            }
    
            return adjacent;
        }
    
        // Place robot randomly
        function placeRobotRandomly(seededRandom) {
            // Find all valid tiles (not obstacles)
            const validTiles = [];
    
            for (let y = 0; y < gridSize; y++) {
                if (!grid[y]) continue;
    
                for (let x = 0; x < gridSize; x++) {
                    // Make sure grid[y][x] exists
                    if (grid[y] && grid[y][x] && grid[y][x].type !== 'obstacle') {
                        validTiles.push({ x, y });
                    }
                }
            }
    
            // Select a random valid tile
            if (validTiles.length > 0) {
                const randomIndex = Math.floor(seededRandom() * validTiles.length);
                const randomPosition = validTiles[randomIndex];
    
                robot.x = randomPosition.x;
                robot.y = randomPosition.y;
            } else {
                // Fallback if no valid tiles (shouldn't happen)
                robot.x = Math.floor(gridSize / 2);
                robot.y = Math.floor(gridSize / 2);
            }
        }
    
        // Generate grid using seeded random function
        function generateGrid(seededRandom) {
            // Create empty grid
            grid = Array.from({ length: gridSize }, (_, y) =>
                Array.from({ length: gridSize }, (_, x) => ({
                    x,
                    y,
                    revealed: false,
                    scanned: false,
                    type: 'empty',
                    variant: 0,
                    isAnomaly: false,
                    isRelic: false
                }))
            );
    
            // Make sure the robot's starting position is empty
            grid[robot.y][robot.x].type = 'empty';
            grid[robot.y][robot.x].revealed = true;
    
            // Apply difficulty modifiers to resource distribution
            const difficultyModifier = {
                "easy": { minerals: 1.2, crystals: 1.2, exotic: 1.5, energy: 1.3, obstacle: 0.8 },
                "normal": { minerals: 1.0, crystals: 1.0, exotic: 1.0, energy: 1.0, obstacle: 1.0 },
                "hard": { minerals: 0.8, crystals: 0.8, exotic: 0.8, energy: 0.7, obstacle: 1.2 },
                "extreme": { minerals: 0.6, crystals: 0.6, exotic: 0.7, energy: 0.5, obstacle: 1.5 }
            };
    
            // Get resource distribution with difficulty applied
            const resourceDist = { ...currentPlanet.type.resourceDistribution };
            for (const resource in resourceDist) {
                if (difficultyModifier[difficulty][resource]) {
                    resourceDist[resource] *= difficultyModifier[difficulty][resource];
                }
            }
    
            // Place resources based on planet type distribution
            for (let y = 0; y < gridSize; y++) {
                for (let x = 0; x < gridSize; x++) {
                    // Skip the robot's starting position
                    if (x === robot.x && y === robot.y) {
                        continue;
                    }
    
                    const rand = seededRandom();
                    const dist = resourceDist;
    
                    if (rand < dist.minerals) {
                        grid[y][x].type = 'minerals';
                        grid[y][x].variant = Math.floor(seededRandom() * 3);
                    } else if (rand < dist.minerals + dist.crystals) {
                        grid[y][x].type = 'crystals';
                        grid[y][x].variant = Math.floor(seededRandom() * 2);
                    } else if (rand < dist.minerals + dist.crystals + dist.exotic) {
                        grid[y][x].type = 'exotic';
                        grid[y][x].variant = Math.floor(seededRandom() * 2);
                    } else if (rand < dist.minerals + dist.crystals + dist.exotic + dist.energy) {
                        grid[y][x].type = 'energy';
                    } else if (rand < dist.minerals + dist.crystals + dist.exotic + dist.energy + dist.obstacle) {
                        grid[y][x].type = 'obstacle';
                        grid[y][x].variant = Math.floor(seededRandom() * 3);
                    }
                }
            }
    
            // Ensure there are enough resources to complete the mission
            const mineralCount = grid.flat().filter(tile => tile.type === 'minerals').length;
            const crystalCount = grid.flat().filter(tile => tile.type === 'crystals').length;
    
            // Make sure we have at least enough minerals and crystals to build base and ship
            if (mineralCount < 8) {
                let additionalNeeded = 8 - mineralCount;
                while (additionalNeeded > 0) {
                    const x = Math.floor(seededRandom() * gridSize);
                    const y = Math.floor(seededRandom() * gridSize);
                    if (grid[y][x].type === 'empty' && !(x === robot.x && y === robot.y)) {
                        grid[y][x].type = 'minerals';
                        grid[y][x].variant = Math.floor(seededRandom() * 3);
                        additionalNeeded--;
                    }
                }
            }
    
            if (crystalCount < 2) {
                let additionalNeeded = 2 - crystalCount;
                while (additionalNeeded > 0) {
                    const x = Math.floor(seededRandom() * gridSize);
                    const y = Math.floor(seededRandom() * gridSize);
                    if (grid[y][x].type === 'empty' && !(x === robot.x && y === robot.y)) {
                        grid[y][x].type = 'crystals';
                        grid[y][x].variant = Math.floor(seededRandom() * 2);
                        additionalNeeded--;
                    }
                }
            }
        }
    
        function drawGrid() {
            // Ensure canvas and context exist
            if (!canvas || !ctx) {
                return;
            }
    
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
    
            // Apply planet background tint
            if (currentPlanet && currentPlanet.color) {
                ctx.fillStyle = currentPlanet.color + '22'; // Transparent version of planet color
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }
    
            // Draw grid lines
            ctx.strokeStyle = '#3476';
            ctx.lineWidth = 1;
            for (let i = 0; i <= gridSize; i++) {
                // Vertical lines
                ctx.beginPath();
                ctx.moveTo(i * tileSize, 0);
                ctx.lineTo(i * tileSize, canvas.height);
                ctx.stroke();
    
                // Horizontal lines
                ctx.beginPath();
                ctx.moveTo(0, i * tileSize);
                ctx.lineTo(canvas.width, i * tileSize);
                ctx.stroke();
            }
    
            // Make sure grid exists
            if (!grid || !grid.length) {
                return;
            }
    
            // Draw tiles
            for (let y = 0; y < gridSize; y++) {
                if (!grid[y]) continue;
    
                for (let x = 0; x < gridSize; x++) {
                    if (!grid[y][x]) continue;
    
                    const tile = grid[y][x];
    
                    // Draw base tile
                    if (!tile.revealed) {
                        // Unexplored tile
                        ctx.fillStyle = '#111a';
                        ctx.fillRect(x * tileSize, y * tileSize, tileSize, tileSize);
    
                        if (tile.scanned) {
                            // Draw scan pattern
                            ctx.fillStyle = '#3af3';
                            ctx.beginPath();
                            for (let i = 0; i < 3; i++) {
                                for (let j = 0; j < 3; j++) {
                                    if ((i + j) % 2 === 0) {
                                        ctx.fillRect(
                                            x * tileSize + i * (tileSize / 3),
                                            y * tileSize + j * (tileSize / 3),
                                            tileSize / 3,
                                            tileSize / 3
                                        );
                                    }
                                }
                            }
                        }
                    } else {
                        // Revealed tile - draw base on planet surface
                        const variant = tile.variant || 0;
    
                        // Draw tile type
                        switch (tile.type) {
                            case 'empty':
                                ctx.fillStyle = currentPlanet.color + '4D'; // 30% opacity
                                break;
                            case 'minerals':
                                ctx.fillStyle = '#6f6';
                                if (variant === 0) drawMineralDeposit1(x, y);
                                else if (variant === 1) drawMineralDeposit2(x, y);
                                else drawMineralDeposit3(x, y);
                                break;
                            case 'crystals':
                                ctx.fillStyle = '#f4f';
                                if (variant === 0) drawCrystalFormation1(x, y);
                                else drawCrystalFormation2(x, y);
                                break;
                            case 'exotic':
                                ctx.fillStyle = '#b4f';
                                if (variant === 0) drawExoticMaterial1(x, y);
                                else drawExoticMaterial2(x, y);
                                break;
                            case 'energy':
                                ctx.fillStyle = '#fd3';
                                drawEnergySource(x, y);
                                break;
                            case 'obstacle':
                                ctx.fillStyle = '#666';
                                if (variant === 0) drawObstacle1(x, y);
                                else if (variant === 1) drawObstacle2(x, y);
                                else drawObstacle3(x, y);
                                break;
                            case 'base':
                                ctx.fillStyle = '#39f';
                                drawBase(x, y);
                                break;
                            case 'ship':
                                ctx.fillStyle = '#f93';
                                drawShip(x, y);
                                break;
                            default:
                                ctx.fillStyle = '#888';
                        }
                    }
    
                    // Draw anomaly indicator if revealed
                    if (tile.isAnomaly && tile.revealed) {
                        drawAnomalyIndicator(x, y);
                    } else if (tile.isAnomaly && tile.scanned) {
                        // Draw a hint for scanned but not revealed anomalies
                        drawAnomalyHint(x, y);
                    }
                    
                    // Draw relic indicator if revealed
                    if (tile.isRelic && tile.revealed) {
                        drawRelicIndicator(x, y);
                    } else if (tile.isRelic && tile.scanned) {
                        // Draw a hint for scanned but not revealed relics
                        drawRelicHint(x, y);
                    }
    
                    // Draw special mission target indicators
                    if (specialMission) {
                        if (specialMission.parameters.type === "investigate" &&
                            specialMission.parameters.target.x === x &&
                            specialMission.parameters.target.y === y) {
                            drawSpecialMissionIndicator(x, y);
                        }
        
                        if (specialMission.parameters.type === "collect_cache" &&
                            specialMission.parameters.target.x === x &&
                            specialMission.parameters.target.y === y) {
                            drawCacheIndicator(x, y);
                        }
                        
                        if (specialMission.parameters.type === "access_archive" &&
                            specialMission.parameters.target.x === x &&
                            specialMission.parameters.target.y === y) {
                            drawArchiveIndicator(x, y);
                        }
                        
                        if (specialMission.parameters.type === "stabilize_points") {
                            // Draw all target points
                            for (let i = 0; i < specialMission.parameters.targets.length; i++) {
                                const target = specialMission.parameters.targets[i];
                                if (target.x === x && target.y === y) {
                                    // Draw differently based on whether this point has been stabilized
                                    if (i < specialMission.parameters.currentTarget) {
                                        drawStabilizedPointIndicator(x, y);
                                    } else {
                                        drawUnstabilizedPointIndicator(x, y);
                                    }
                                }
                            }
                        }
                    }
                }
            }
    
            // Draw robot
            if (typeof robot.x !== 'undefined' && typeof robot.y !== 'undefined') {
                drawRobot(robot.x, robot.y);
    
                // Draw highlight around current tile
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;
                ctx.strokeRect(
                    robot.x * tileSize + 2,
                    robot.y * tileSize + 2,
                    tileSize - 4,
                    tileSize - 4
                );
            }
    
            // Draw FPS counter if enabled
            if (showFps) {
                ctx.fillStyle = "white";
                ctx.font = "12px monospace";
                ctx.fillText(`FPS: ${fps}`, 10, 20);
            }
        }
        
        // Draw stabilized quantum point indicator
        function drawStabilizedPointIndicator(x, y) {
            const centerX = x * tileSize + tileSize / 2;
            const centerY = y * tileSize + tileSize / 2;
            const radius = tileSize * 0.25;
            
            // Draw a stabilized point (more solid)
            ctx.fillStyle = 'rgba(64, 255, 170, 0.3)';
            ctx.beginPath();
            ctx.arc(centerX, centerY, radius * 1.5, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.strokeStyle = 'rgba(64, 255, 170, 0.8)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
            ctx.stroke();
            
            // Draw stabilization icon
            ctx.strokeStyle = 'rgba(64, 255, 170, 0.8)';
            ctx.beginPath();
            ctx.moveTo(centerX - radius * 0.5, centerY);
            ctx.lineTo(centerX + radius * 0.5, centerY);
            ctx.stroke();
            
            ctx.beginPath();
            ctx.moveTo(centerX, centerY - radius * 0.5);
            ctx.lineTo(centerX, centerY + radius * 0.5);
            ctx.stroke();
        }
        
        // Draw unstabilized quantum point indicator
        function drawUnstabilizedPointIndicator(x, y) {
            const centerX = x * tileSize + tileSize / 2;
            const centerY = y * tileSize + tileSize / 2;
            const radius = tileSize * 0.25;
            
            // Animation pulse
            const pulseScale = 0.8 + Math.sin(Date.now() / 200) * 0.2;
            
            // Draw unstable point (pulsing and fluctuating)
            ctx.fillStyle = 'rgba(255, 100, 100, 0.2)';
            ctx.beginPath();
            ctx.arc(centerX, centerY, radius * pulseScale * 1.5, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.strokeStyle = 'rgba(255, 100, 100, 0.8)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(centerX, centerY, radius * pulseScale, 0, Math.PI * 2);
            ctx.stroke();
            
            // Draw fluctuation icon - wavey line
            ctx.strokeStyle = 'rgba(255, 100, 100, 0.8)';
            ctx.beginPath();
            ctx.moveTo(centerX - radius * 0.6, centerY);
            ctx.quadraticCurveTo(
                centerX - radius * 0.2, 
                centerY - radius * 0.4 * pulseScale, 
                centerX, 
                centerY
            );
            ctx.quadraticCurveTo(
                centerX + radius * 0.2, 
                centerY + radius * 0.4 * pulseScale, 
                centerX + radius * 0.6, 
                centerY
            );
            ctx.stroke();
        }
        
        // Draw archive indicator
        function drawArchiveIndicator(x, y) {
            const centerX = x * tileSize + tileSize / 2;
            const centerY = y * tileSize + tileSize / 2;
            const size = tileSize * 0.3;
            
            // Draw archive base
            ctx.fillStyle = 'rgba(100, 200, 255, 0.3)';
            ctx.fillRect(
                centerX - size, 
                centerY - size, 
                size * 2, 
                size * 2
            );
            
            // Draw pulse effect
            const pulseScale = 0.8 + Math.sin(Date.now() / 500) * 0.2;
            ctx.strokeStyle = 'rgba(100, 200, 255, 0.8)';
            ctx.lineWidth = 2;
            ctx.strokeRect(
                centerX - size * pulseScale, 
                centerY - size * pulseScale, 
                size * 2 * pulseScale, 
                size * 2 * pulseScale
            );
            
            // Draw data lines
            for (let i = 0; i < 3; i++) {
                const lineY = centerY - size + (size * 0.5) + (i * size * 0.5);
                ctx.beginPath();
                ctx.moveTo(centerX - size * 0.7, lineY);
                ctx.lineTo(centerX + size * 0.7, lineY);
                ctx.stroke();
            }
        }
        
        // Draw relic indicator
        function drawRelicIndicator(x, y) {
            const centerX = x * tileSize + tileSize / 2;
            const centerY = y * tileSize + tileSize / 2;
            const radius = tileSize * 0.25;
            
            // Get the relic ID
            const relicId = grid[y][x].relicId;
            const relic = RELICS.find(r => r.id === relicId);
            
            // Draw glowing circle
            const pulseScale = 0.8 + Math.sin(Date.now() / 300) * 0.2;
            
            // Create gradient
            const gradient = ctx.createRadialGradient(
                centerX, centerY, 0,
                centerX, centerY, radius * 2 * pulseScale
            );
            gradient.addColorStop(0, 'rgba(180, 100, 255, 0.7)');
            gradient.addColorStop(0.5, 'rgba(180, 100, 255, 0.3)');
            gradient.addColorStop(1, 'rgba(180, 100, 255, 0)');
            
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(centerX, centerY, radius * 2 * pulseScale, 0, Math.PI * 2);
            ctx.fill();
            
            // Draw relic icon if available
            ctx.fillStyle = 'white';
            ctx.font = `${Math.floor(tileSize * 0.4)}px Arial`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(relic ? relic.icon : 'üè∫', centerX, centerY);
        }
        
        // Draw relic hint
        function drawRelicHint(x, y) {
            const centerX = x * tileSize + tileSize / 2;
            const centerY = y * tileSize + tileSize / 2;
            
            // Draw subtle indicator for scanned but not revealed relic
            ctx.fillStyle = 'rgba(180, 100, 255, 0.3)';
            ctx.beginPath();
            ctx.arc(centerX, centerY, tileSize * 0.1, 0, Math.PI * 2);
            ctx.fill();
            
            // Add pulsing effect
            const pulseTime = Date.now() / 500;
            if (Math.sin(pulseTime) > 0.7) {
                ctx.fillStyle = 'rgba(180, 100, 255, 0.5)';
                ctx.beginPath();
                ctx.arc(centerX, centerY, tileSize * 0.08, 0, Math.PI * 2);
                ctx.fill();
            }
        }
    
        // Draw anomaly indicator
        function drawAnomalyIndicator(x, y) {
            const centerX = x * tileSize + tileSize / 2;
            const centerY = y * tileSize + tileSize / 2;
            const radius = tileSize * 0.2;
    
            // Draw pulsing circle
            const pulseScale = 0.8 + Math.sin(Date.now() / 300) * 0.2;
    
            ctx.fillStyle = 'rgba(255, 255, 0, 0.3)';
            ctx.beginPath();
            ctx.arc(centerX, centerY, radius * pulseScale * 1.5, 0, Math.PI * 2);
            ctx.fill();
    
            ctx.fillStyle = 'rgba(255, 255, 0, 0.6)';
            ctx.beginPath();
            ctx.arc(centerX, centerY, radius * pulseScale, 0, Math.PI * 2);
            ctx.fill();
    
            // Draw question mark
            ctx.fillStyle = 'white';
            ctx.font = `${Math.floor(tileSize * 0.4)}px Arial`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('?', centerX, centerY);
        }
        
        // Draw anomaly hint
        function drawAnomalyHint(x, y) {
            const centerX = x * tileSize + tileSize / 2;
            const centerY = y * tileSize + tileSize / 2;
            
            // Draw subtle indicator for scanned but not revealed anomaly
            ctx.fillStyle = 'rgba(255, 255, 0, 0.3)';
            ctx.beginPath();
            ctx.arc(centerX, centerY, tileSize * 0.1, 0, Math.PI * 2);
            ctx.fill();
            
            // Add pulsing effect
            const pulseTime = Date.now() / 500;
            if (Math.sin(pulseTime) > 0.7) {
                ctx.fillStyle = 'rgba(255, 255, 0, 0.5)';
                ctx.beginPath();
                ctx.arc(centerX, centerY, tileSize * 0.08, 0, Math.PI * 2);
                ctx.fill();
            }
        }
    
        // Draw special mission indicator
        function drawSpecialMissionIndicator(x, y) {
            const centerX = x * tileSize + tileSize / 2;
            const centerY = y * tileSize + tileSize / 2;
            const radius = tileSize * 0.25;
    
            // Draw pulsing circle
            const pulseScale = 0.8 + Math.sin(Date.now() / 200) * 0.2;
    
            ctx.fillStyle = 'rgba(64, 170, 255, 0.2)';
            ctx.beginPath();
            ctx.arc(centerX, centerY, radius * pulseScale * 1.5, 0, Math.PI * 2);
            ctx.fill();
    
            ctx.strokeStyle = 'rgba(64, 170, 255, 0.8)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(centerX, centerY, radius * pulseScale, 0, Math.PI * 2);
            ctx.stroke();
    
            // Draw signal icon
            ctx.strokeStyle = 'rgba(64, 170, 255, 0.8)';
            ctx.lineWidth = 2;
            ctx.beginPath();
    
            const signalSize = radius * 0.7;
            for (let i = 0; i < 3; i++) {
                const arcRadius = signalSize * (i + 1) / 3;
                ctx.arc(centerX, centerY, arcRadius, Math.PI * 0.8, Math.PI * 0.2, true);
            }
    
            ctx.stroke();
        }
    
        // Draw cache indicator
        function drawCacheIndicator(x, y) {
            const centerX = x * tileSize + tileSize / 2;
            const centerY = y * tileSize + tileSize / 2;
            const size = tileSize * 0.4;
    
            // Draw pulsing square
            const pulseScale = 0.8 + Math.sin(Date.now() / 250) * 0.2;
    
            ctx.fillStyle = 'rgba(255, 153, 51, 0.2)';
            ctx.fillRect(
                centerX - size * pulseScale * 0.75,
                centerY - size * pulseScale * 0.75,
                size * pulseScale * 1.5,
                size * pulseScale * 1.5
            );
    
            // Draw chest icon
            ctx.fillStyle = 'rgba(255, 153, 51, 0.8)';
            ctx.fillRect(
                centerX - size * pulseScale * 0.5,
                centerY - size * pulseScale * 0.3,
                size * pulseScale,
                size * pulseScale * 0.6
            );
    
            // Chest lid
            ctx.beginPath();
            ctx.moveTo(centerX - size * pulseScale * 0.5, centerY - size * pulseScale * 0.3);
            ctx.lineTo(centerX, centerY - size * pulseScale * 0.5);
            ctx.lineTo(centerX + size * pulseScale * 0.5, centerY - size * pulseScale * 0.3);
            ctx.fill();
        }
    
        // Tile drawing functions
        function drawMineralDeposit1(x, y) {
            const centerX = x * tileSize + tileSize / 2;
            const centerY = y * tileSize + tileSize / 2;
    
            ctx.fillStyle = '#6f6';
            ctx.fillRect(x * tileSize, y * tileSize, tileSize, tileSize);
    
            ctx.fillStyle = '#4d4';
            for (let i = 0; i < 5; i++) {
                const offsetX = (Math.random() - 0.5) * tileSize * 0.7;
                const offsetY = (Math.random() - 0.5) * tileSize * 0.7;
                const size = 6 + Math.random() * 10;
    
                ctx.beginPath();
                ctx.arc(centerX + offsetX, centerY + offsetY, size, 0, Math.PI * 2);
                ctx.fill();
            }
        }
    
        function drawMineralDeposit2(x, y) {
            ctx.fillStyle = '#6f6';
            ctx.fillRect(x * tileSize, y * tileSize, tileSize, tileSize);
    
            ctx.fillStyle = '#4d4';
            ctx.beginPath();
            ctx.moveTo(x * tileSize + 10, y * tileSize + 10);
            ctx.lineTo(x * tileSize + tileSize - 10, y * tileSize + 20);
            ctx.lineTo(x * tileSize + tileSize - 20, y * tileSize + tileSize - 10);
            ctx.lineTo(x * tileSize + 15, y * tileSize + tileSize - 15);
            ctx.closePath();
            ctx.fill();
        }
    
        function drawMineralDeposit3(x, y) {
            ctx.fillStyle = '#6f6';
            ctx.fillRect(x * tileSize, y * tileSize, tileSize, tileSize);
    
            ctx.fillStyle = '#4d4';
            const stripeCount = 5;
            const stripeWidth = tileSize / stripeCount;
    
            for (let i = 0; i < stripeCount; i += 2) {
                ctx.fillRect(
                    x * tileSize,
                    y * tileSize + i * stripeWidth,
                    tileSize,
                    stripeWidth
                );
            }
        }
    
        function drawCrystalFormation1(x, y) {
            ctx.fillStyle = '#f4f6';
            ctx.fillRect(x * tileSize, y * tileSize, tileSize, tileSize);
    
            // Draw several crystal shapes
            ctx.fillStyle = '#f4f';
            const centerX = x * tileSize + tileSize / 2;
            const centerY = y * tileSize + tileSize / 2;
    
            // Main crystal
            ctx.beginPath();
            ctx.moveTo(centerX, centerY - tileSize * 0.3);
            ctx.lineTo(centerX + tileSize * 0.2, centerY);
            ctx.lineTo(centerX, centerY + tileSize * 0.3);
            ctx.lineTo(centerX - tileSize * 0.2, centerY);
            ctx.closePath();
            ctx.fill();
    
            // Smaller crystals
            for (let i = 0; i < 3; i++) {
                const angle = Math.random() * Math.PI * 2;
                const distance = tileSize * 0.3;
                const size = tileSize * 0.15;
    
                const crystalX = centerX + Math.cos(angle) * distance;
                const crystalY = centerY + Math.sin(angle) * distance;
    
                ctx.beginPath();
                ctx.moveTo(crystalX, crystalY - size);
                ctx.lineTo(crystalX + size * 0.7, crystalY);
                ctx.lineTo(crystalX, crystalY + size);
                ctx.lineTo(crystalX - size * 0.7, crystalY);
                ctx.closePath();
                ctx.fill();
            }
        }
    
        function drawCrystalFormation2(x, y) {
            ctx.fillStyle = '#f4f6';
            ctx.fillRect(x * tileSize, y * tileSize, tileSize, tileSize);
    
            ctx.fillStyle = '#f4f';
            const positions = [
                { x: 0.3, y: 0.2, width: 0.15, height: 0.4, angle: -15 },
                { x: 0.5, y: 0.3, width: 0.1, height: 0.5, angle: 10 },
                { x: 0.7, y: 0.4, width: 0.12, height: 0.35, angle: -5 }
            ];
    
            positions.forEach(pos => {
                const centerX = x * tileSize + pos.x * tileSize;
                const centerY = y * tileSize + pos.y * tileSize;
                const width = pos.width * tileSize;
                const height = pos.height * tileSize;
                const angleRad = pos.angle * Math.PI / 180;
    
                ctx.save();
                ctx.translate(centerX, centerY);
                ctx.rotate(angleRad);
    
                ctx.beginPath();
                ctx.moveTo(0, -height / 2);
                ctx.lineTo(width / 2, 0);
                ctx.lineTo(0, height / 2);
                ctx.lineTo(-width / 2, 0);
                ctx.closePath();
                ctx.fill();
    
                ctx.restore();
            });
        }
        
        function drawExoticMaterial1(x, y) {
            const centerX = x * tileSize + tileSize / 2;
            const centerY = y * tileSize + tileSize / 2;
            const radius = tileSize * 0.4;
            
            // Background
            ctx.fillStyle = '#b4f3';
            ctx.fillRect(x * tileSize, y * tileSize, tileSize, tileSize);
            
            // Create a pulsing animation based on time
            const animTime = Date.now() / 1000;
            const pulseScale = 0.8 + Math.sin(animTime * 2) * 0.2;
            
            // Drawing weird, exotic patterns
            ctx.fillStyle = '#b4f';
            
            // Draw geometric pattern
            for (let i = 0; i < 3; i++) {
                const angle = (i / 3) * Math.PI * 2 + animTime * 0.5;
                const orbitRadius = radius * 0.6;
                const orbitX = centerX + Math.cos(angle) * orbitRadius;
                const orbitY = centerY + Math.sin(angle) * orbitRadius;
                
                // Draw exotic matter particle
                ctx.beginPath();
                ctx.arc(orbitX, orbitY, radius * 0.15 * pulseScale, 0, Math.PI * 2);
                ctx.fill();
                
                // Draw connecting line to center
                ctx.strokeStyle = '#b4f';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(centerX, centerY);
                ctx.lineTo(orbitX, orbitY);
                ctx.stroke();
            }
            
            // Central core
            ctx.fillStyle = '#d8f';
            ctx.beginPath();
            ctx.arc(centerX, centerY, radius * 0.2 * pulseScale, 0, Math.PI * 2);
            ctx.fill();
            
            // Glow effect
            ctx.fillStyle = 'rgba(180, 64, 255, 0.3)';
            ctx.beginPath();
            ctx.arc(centerX, centerY, radius * pulseScale, 0, Math.PI * 2);
            ctx.fill();
        }
        
        function drawExoticMaterial2(x, y) {
            const centerX = x * tileSize + tileSize / 2;
            const centerY = y * tileSize + tileSize / 2;
            
            // Background
            ctx.fillStyle = '#b4f3';
            ctx.fillRect(x * tileSize, y * tileSize, tileSize, tileSize);
            
            // Animation time
            const animTime = Date.now() / 700;
            
            // Draw fractal pattern
            ctx.strokeStyle = '#b4f';
            ctx.lineWidth = 2;
            
            // Main shape
            const size = tileSize * 0.3;
            const points = [];
            
            // Create a 5-pointed star/fractal shape
            for (let i = 0; i < 5; i++) {
                const angle = (i / 5) * Math.PI * 2 + animTime * 0.2;
                const outerRadius = size;
                const innerRadius = size * 0.5;
                
                // Outer point
                points.push({
                    x: centerX + Math.cos(angle) * outerRadius,
                    y: centerY + Math.sin(angle) * outerRadius
                });
                
                // Inner point
                const innerAngle = angle + Math.PI / 5;
                points.push({
                    x: centerX + Math.cos(innerAngle) * innerRadius,
                    y: centerY + Math.sin(innerAngle) * innerRadius
                });
            }
            
            // Draw the shape
            ctx.beginPath();
            ctx.moveTo(points[0].x, points[0].y);
            for (let i = 1; i < points.length; i++) {
                ctx.lineTo(points[i].x, points[i].y);
            }
            ctx.closePath();
            ctx.stroke();
            ctx.fillStyle = 'rgba(180, 64, 255, 0.6)';
            ctx.fill();
            
            // Outer glow
            ctx.fillStyle = 'rgba(180, 64, 255, 0.2)';
            ctx.beginPath();
            ctx.arc(centerX, centerY, size * 1.2, 0, Math.PI * 2);
            ctx.fill();
            
            // Center dot
            ctx.fillStyle = '#f8f';
            ctx.beginPath();
            ctx.arc(centerX, centerY, size * 0.2, 0, Math.PI * 2);
            ctx.fill();
        }

        function drawEnergySource(x, y) {
            ctx.fillStyle = '#fd31';
            ctx.fillRect(x * tileSize, y * tileSize, tileSize, tileSize);

            const centerX = x * tileSize + tileSize / 2;
            const centerY = y * tileSize + tileSize / 2;
            const radius = tileSize * 0.3;

            // Draw energy orb
            const gradient = ctx.createRadialGradient(
                centerX, centerY, 0,
                centerX, centerY, radius * 1.5
            );
            gradient.addColorStop(0, '#fff');
            gradient.addColorStop(0.3, '#fd3');
            gradient.addColorStop(1, '#fd30');

            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(centerX, centerY, radius * 1.5, 0, Math.PI * 2);
            ctx.fill();

            // Energy pulses - use Date.now() for animation
            const animationPhase = Date.now() / 1000;
            for (let i = 0; i < 4; i++) {
                const angle = (i * Math.PI / 2) + (animationPhase % 20) * 0.1;
                const pulseX = centerX + Math.cos(angle) * radius * 0.8;
                const pulseY = centerY + Math.sin(angle) * radius * 0.8;

                ctx.fillStyle = '#fff9';
                ctx.beginPath();
                ctx.arc(pulseX, pulseY, radius * 0.2, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        function drawObstacle1(x, y) {
            // Rocky obstacle
            ctx.fillStyle = '#666';
            ctx.fillRect(x * tileSize, y * tileSize, tileSize, tileSize);

            ctx.fillStyle = '#444';
            const centerX = x * tileSize + tileSize / 2;
            const centerY = y * tileSize + tileSize / 2;

            for (let i = 0; i < 5; i++) {
                const angle = (i / 5) * Math.PI * 2;
                const radius = tileSize * 0.3;
                const rockX = centerX + Math.cos(angle) * radius * 0.5;
                const rockY = centerY + Math.sin(angle) * radius * 0.5;
                const rockSize = tileSize * (0.15 + Math.random() * 0.1);

                ctx.beginPath();
                ctx.arc(rockX, rockY, rockSize, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        function drawObstacle2(x, y) {
            // Crevasse obstacle
            ctx.fillStyle = '#666';
            ctx.fillRect(x * tileSize, y * tileSize, tileSize, tileSize);

            ctx.fillStyle = '#222';
            const centerX = x * tileSize + tileSize / 2;
            const centerY = y * tileSize + tileSize / 2;

            ctx.beginPath();
            ctx.moveTo(centerX - tileSize * 0.3, centerY - tileSize * 0.25);
            ctx.lineTo(centerX + tileSize * 0.2, centerY - tileSize * 0.1);
            ctx.lineTo(centerX + tileSize * 0.35, centerY + tileSize * 0.3);
            ctx.lineTo(centerX - tileSize * 0.2, centerY + tileSize * 0.2);
            ctx.closePath();
            ctx.fill();
        }

        function drawObstacle3(x, y) {
            // Jagged rocks obstacle
            ctx.fillStyle = '#666';
            ctx.fillRect(x * tileSize, y * tileSize, tileSize, tileSize);

            ctx.fillStyle = '#444';

            // Draw jagged pattern
            ctx.beginPath();
            ctx.moveTo(x * tileSize, y * tileSize);

            for (let i = 0; i < 5; i++) {
                const peakX = x * tileSize + (i + 0.5) * (tileSize / 5);
                const peakY = y * tileSize + (Math.random() * 0.4 + 0.1) * tileSize;
                ctx.lineTo(peakX, peakY);

                const valleyX = x * tileSize + (i + 1) * (tileSize / 5);
                const valleyY = y * tileSize + (Math.random() * 0.3 + 0.6) * tileSize;
                ctx.lineTo(valleyX, valleyY);
            }

            ctx.lineTo(x * tileSize + tileSize, y * tileSize + tileSize);
            ctx.lineTo(x * tileSize, y * tileSize + tileSize);
            ctx.closePath();
            ctx.fill();
        }

        function drawBase(x, y) {
            ctx.fillStyle = '#39f3';
            ctx.fillRect(x * tileSize, y * tileSize, tileSize, tileSize);

            const centerX = x * tileSize + tileSize / 2;
            const centerY = y * tileSize + tileSize / 2;
            const baseSize = tileSize * 0.8;

            // Base platform
            ctx.fillStyle = '#39f';
            ctx.beginPath();
            ctx.arc(centerX, centerY, baseSize * 0.4, 0, Math.PI * 2);
            ctx.fill();

            // Base structures
            ctx.fillStyle = '#248';

            // Central tower
            ctx.fillRect(
                centerX - baseSize * 0.1,
                centerY - baseSize * 0.3,
                baseSize * 0.2,
                baseSize * 0.6
            );

            // Side modules
            ctx.fillRect(
                centerX - baseSize * 0.35,
                centerY - baseSize * 0.15,
                baseSize * 0.15,
                baseSize * 0.3
            );

            ctx.fillRect(
                centerX + baseSize * 0.2,
                centerY - baseSize * 0.15,
                baseSize * 0.15,
                baseSize * 0.3
            );

            // Antenna
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(centerX, centerY - baseSize * 0.3);
            ctx.lineTo(centerX, centerY - baseSize * 0.45);
            ctx.stroke();

            // Base energy field - animated
            const animationPhase = Date.now() / 1000;
            ctx.strokeStyle = 'rgba(64, 170, 255, 0.6)';
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            ctx.arc(centerX, centerY, baseSize * 0.45 + Math.sin(animationPhase * 3) * 2, 0, Math.PI * 2);
            ctx.stroke();
            ctx.setLineDash([]);

            // Add pulsing energy orb
            const pulseSize = (0.8 + Math.sin(animationPhase * 4) * 0.2);
            ctx.fillStyle = 'rgba(64, 170, 255, 0.3)';
            ctx.beginPath();
            ctx.arc(centerX, centerY - baseSize * 0.3, baseSize * 0.1 * pulseSize, 0, Math.PI * 2);
            ctx.fill();
        }

        function drawShip(x, y) {
            ctx.fillStyle = '#f938';
            ctx.fillRect(x * tileSize, y * tileSize, tileSize, tileSize);

            const centerX = x * tileSize + tileSize / 2;
            const centerY = y * tileSize + tileSize / 2;
            const shipSize = tileSize * 0.7;

            // Animated hover effect
            const animationPhase = Date.now() / 1000;
            const hoverOffset = Math.sin(animationPhase * 2) * 2;

            // Ship body
            ctx.fillStyle = '#f93';
            ctx.beginPath();
            ctx.moveTo(centerX, centerY - shipSize * 0.4 + hoverOffset);
            ctx.lineTo(centerX + shipSize * 0.3, centerY + shipSize * 0.2 + hoverOffset);
            ctx.lineTo(centerX - shipSize * 0.3, centerY + shipSize * 0.2 + hoverOffset);
            ctx.closePath();
            ctx.fill();

            // Ship details
            ctx.fillStyle = '#c62';
            ctx.beginPath();
            ctx.moveTo(centerX, centerY - shipSize * 0.3 + hoverOffset);
            ctx.lineTo(centerX + shipSize * 0.2, centerY + shipSize * 0.1 + hoverOffset);
            ctx.lineTo(centerX - shipSize * 0.2, centerY + shipSize * 0.1 + hoverOffset);
            ctx.closePath();
            ctx.fill();

            // Engine glow - animated
            const glowSize = (0.8 + Math.sin(animationPhase * 6) * 0.2);
            const gradient = ctx.createRadialGradient(
                centerX, centerY + shipSize * 0.25 + hoverOffset, 0,
                centerX, centerY + shipSize * 0.25 + hoverOffset, shipSize * 0.15
            );
            gradient.addColorStop(0, '#fff');
            gradient.addColorStop(0.6, '#fd3');
            gradient.addColorStop(1, 'rgba(255, 221, 51, 0)');

            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(centerX, centerY + shipSize * 0.25 + hoverOffset, shipSize * 0.15 * glowSize, 0, Math.PI * 2);
            ctx.fill();

            // Launch pad
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(centerX - shipSize * 0.4, centerY + shipSize * 0.3);
            ctx.lineTo(centerX + shipSize * 0.4, centerY + shipSize * 0.3);
            ctx.stroke();

            ctx.beginPath();
            ctx.moveTo(centerX - shipSize * 0.3, centerY + shipSize * 0.3);
            ctx.lineTo(centerX - shipSize * 0.4, centerY + shipSize * 0.4);
            ctx.stroke();

            ctx.beginPath();
            ctx.moveTo(centerX + shipSize * 0.3, centerY + shipSize * 0.3);
            ctx.lineTo(centerX + shipSize * 0.4, centerY + shipSize * 0.4);
            ctx.stroke();

            // Add light beam effect
            ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
            ctx.beginPath();
            ctx.moveTo(centerX - shipSize * 0.2, centerY + shipSize * 0.2 + hoverOffset);
            ctx.lineTo(centerX - shipSize * 0.4, centerY + shipSize * 0.4);
            ctx.lineTo(centerX + shipSize * 0.4, centerY + shipSize * 0.4);
            ctx.lineTo(centerX + shipSize * 0.2, centerY + shipSize * 0.2 + hoverOffset);
            ctx.closePath();
            ctx.fill();
        }

        function drawRobot(x, y) {
            const centerX = x * tileSize + tileSize / 2;
            const centerY = y * tileSize + tileSize / 2;
            const robotSize = tileSize * 0.6;

            // Get animation phase for hover effect
            const animationPhase = Date.now() / 1000;
            const hoverOffset = Math.sin(animationPhase * 3) * tileSize * 0.03;

            // Robot body with hover effect
            ctx.fillStyle = '#3af';
            ctx.beginPath();
            ctx.arc(centerX, centerY + hoverOffset, robotSize * 0.4, 0, Math.PI * 2);
            ctx.fill();

            // Robot details
            ctx.fillStyle = '#159';
            ctx.beginPath();
            ctx.arc(centerX, centerY + hoverOffset, robotSize * 0.25, 0, Math.PI * 2);
            ctx.fill();

            // Robot eye/sensor - animated
            ctx.fillStyle = '#fff';
            const eyeX = centerX + robotSize * 0.15 * Math.cos(animationPhase * 0.5);
            const eyeY = centerY + hoverOffset + robotSize * 0.15 * Math.sin(animationPhase * 0.5);
            ctx.beginPath();
            ctx.arc(eyeX, eyeY, robotSize * 0.08, 0, Math.PI * 2);
            ctx.fill();

            // Robot status indicator
            if (robot.statusEffects.length > 0) {
                ctx.fillStyle = '#f93';
                ctx.beginPath();
                ctx.arc(centerX + robotSize * 0.3, centerY + hoverOffset - robotSize * 0.3, robotSize * 0.1, 0, Math.PI * 2);
                ctx.fill();
            }

            // Robot antenna
            ctx.strokeStyle = '#bdf';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(centerX, centerY + hoverOffset - robotSize * 0.4);
            ctx.lineTo(centerX, centerY + hoverOffset - robotSize * 0.6);
            ctx.stroke();

            ctx.fillStyle = '#bdf';
            ctx.beginPath();
            ctx.arc(centerX, centerY + hoverOffset - robotSize * 0.65, robotSize * 0.05, 0, Math.PI * 2);
            ctx.fill();

            // Add energy field effect when active
            if (robot.busy) {
                ctx.strokeStyle = 'rgba(64, 170, 255, 0.6)';
                ctx.lineWidth = 1;
                ctx.setLineDash([3, 3]);
                ctx.beginPath();
                ctx.arc(centerX, centerY + hoverOffset, robotSize * 0.5 + Math.sin(animationPhase * 5) * 2, 0, Math.PI * 2);
                ctx.stroke();
                ctx.setLineDash([]);
            }

            // Add shield effect if protected by a drone
            const shieldEffect = robot.statusEffects.find(e => e.source === 'drone_shield');
            if (shieldEffect) {
                const shieldPulse = 0.9 + Math.sin(animationPhase * 2) * 0.1;
                ctx.strokeStyle = 'rgba(100, 200, 255, 0.6)';
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 3]);
                ctx.beginPath();
                ctx.arc(centerX, centerY + hoverOffset, robotSize * 0.6 * shieldPulse, 0, Math.PI * 2);
                ctx.stroke();
                ctx.setLineDash([]);
            }

            // Add shadow beneath robot
            ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
            ctx.beginPath();
            ctx.ellipse(centerX, centerY + robotSize * 0.4, robotSize * 0.3, robotSize * 0.1, 0, 0, Math.PI * 2);
            ctx.fill();
        }

        // Game actions
        function scanTile() {
    // Base energy cost
    let energyCost = 3;

    // Apply weather and upgrade effects
    if (currentWeather && currentWeather.effect && 
        currentWeather.effect.type === "scan_penalty") {
        energyCost /= currentWeather.effect.value; // Higher cost
    }

    // Apply energy efficiency upgrade
    energyCost *= getUpgradeEffect("efficiency", "energy");

    if (!gameActive) {
        addLogEntry('Mission not active');
        return;
    }

    if (robot.busy) {
        addLogEntry('Robot is busy with another action');
        return;
    }

    if (robot.energy < energyCost) {
        addLogEntry('Insufficient energy for scan');
        return;
    }

    const tile = grid[robot.y][robot.x];

    // If tile is already revealed, inform the player
    if (tile.revealed) {
        addLogEntry('This tile has already been scanned and revealed.');
        return;
    }
    
    // Store last action for potential time reversal
    robot.lastAction = {
        type: "scan",
        x: robot.x,
        y: robot.y,
        energy: robot.energy,
        tile: JSON.parse(JSON.stringify(tile))
    };

    // Set robot to busy state
    robot.busy = true;
    robot.currentAction = "Scanning";
    robot.actionTimeRemaining = 2 * getUpgradeEffect("speed", "scan"); // Scanning takes 2 seconds, modified by upgrades
    robot.actionProgress = 0;

    // Play sound effect
    playSoundEffect('scan');

    // Start the action
    startAction(() => {
        // Complete scanning after action finishes
        tile.scanned = true;
        robot.energy -= Math.round(energyCost);
        robot.scannedTiles++;
        robot.actionsPerformed++;

        addLogEntry(`Scanning tile at (${robot.x}, ${robot.y})...`);

        // Calculate scan success chance with modifiers
        let scanSuccessChance = 0.7; // 70% base chance
        
        // Apply weather penalty if applicable
        if (currentWeather && currentWeather.effect && 
            currentWeather.effect.type === "scan_penalty") {
            scanSuccessChance *= currentWeather.effect.value;
        }
        
        // Check for tech tree scan reveal bonus
        const scanTech = TECH_TREE.find(t => t.id === "scanning_technology" && t.unlocked);
        if (scanTech) {
            const revealEffect = scanTech.effects.find(e => e.type === "scan_reveal");
            if (revealEffect) {
                scanSuccessChance = Math.min(1.0, scanSuccessChance + revealEffect.value);
            }
        }

        // Determine if scan reveals the tile
        if (Math.random() < scanSuccessChance) {
            revealTile(robot.x, robot.y);
            addLogEntry('Scan complete - tile contents identified!');
        } else {
            addLogEntry('Scan detected something. Move onto tile to investigate further.');
        }

        // Check for tech tree scanner range bonus to scan adjacent tiles
        const scannerTech = TECH_TREE.find(t => t.id === "scanning_technology" && t.unlocked);
        if (scannerTech) {
            const rangeEffect = scannerTech.effects.find(e => e.type === "scanner");
            if (rangeEffect) {
                // Scan adjacent tiles based on range
                const range = rangeEffect.value;
                let tilesScanned = 0;
                
                for (let y = Math.max(0, robot.y - range); y <= Math.min(gridSize - 1, robot.y + range); y++) {
                    for (let x = Math.max(0, robot.x - range); x <= Math.min(gridSize - 1, robot.x + range); x++) {
                        // Skip center tile (already scanned)
                        if (x === robot.x && y === robot.y) continue;
                        
                        if (!grid[y][x].scanned) {
                            grid[y][x].scanned = true;
                            tilesScanned++;
                            
                            // Apply scan reveal chance to adjacent tiles too
                            if (Math.random() < scanSuccessChance * 0.5) { // Reduced chance for adjacent tiles
                                grid[y][x].revealed = true;
                                robot.revealedTiles++;
                            }
                        }
                    }
                }
                
                if (tilesScanned > 0) {
                    addLogEntry(`Enhanced scanner revealed ${tilesScanned} surrounding tiles!`);
                }
            }
        }

        // Check for scanning side missions
        checkSideMissionProgress("scan");

        updateUI();
        drawGrid();

        // Check if energy is depleted
        if (robot.energy <= 0) {
            gameOver();
        }
    });
}
        function revealTile(x, y) {
            // Check if coordinates are valid
            if (!grid[y] || !grid[y][x]) {
                return;
            }

            const tile = grid[y][x];
            const wasRevealed = tile.revealed;

            tile.revealed = true;
            tile.scanned = true;

            if (!wasRevealed) {
                robot.revealedTiles++;
                
                // Check for map reveal side mission
                checkSideMissionProgress("map_reveal");
            }

            // Apply any immediate effects
            if (tile.type === 'energy') {
                // Base energy gain
                let energyGain = 15 + Math.floor(Math.random() * 15); // 15-30 energy

                // Apply weather boost if applicable
                if (currentWeather && currentWeather.effect && 
                    currentWeather.effect.type === "energy_boost") {
                    energyGain = Math.floor(energyGain * currentWeather.effect.value);
                }

                robot.energy = Math.min(robot.maxEnergy, robot.energy + energyGain);
                addLogEntry(`Energy source discovered! +${energyGain} energy`);

                // Remove the energy source after use
                tile.type = 'empty';
            }

            // Check for anomaly on the revealed tile
            if (tile.isAnomaly) {
                const anomaly = activeAnomalies.find(a => a.x === x && a.y === y);
                if (anomaly && !anomaly.discovered) {
                    anomaly.discovered = true;
                    foundAnomalies++;

                    // Show the special event
                    showSpecialEvent(anomaly.eventData);

                    // Check for anomaly-related side missions
                    checkSideMissionProgress("anomaly", { x, y });
                    
                    // Update achievement progress
                    updateAchievementProgress("anomaly_analyst", 1);
                }
            }
            
            // Check for relic on the revealed tile
            if (tile.isRelic) {
                const relicId = tile.relicId;
                if (relicId) {
                    // Add the relic to discovered relics
                    addRelic(relicId);
                    
                    // Remove relic marker from tile
                    tile.isRelic = false;
                    tile.relicId = null;
                }
            }

            // Check special mission progress
            checkSpecialMissionProgress();

            updateObjectiveDisplay();
        }

        function moveRobot(direction) {
    // Base energy cost
    let energyCost = 3;

    // Apply efficiency upgrades
    energyCost *= getUpgradeEffect("efficiency", "movement");

    if (!gameActive) {
        addLogEntry('Mission not active');
        return;
    }

    if (robot.busy) {
        addLogEntry('Robot is busy with another action');
        return;
    }

    if (robot.energy < energyCost) {
        addLogEntry('Insufficient energy for movement');
        return;
    }

    // Calculate new position
    let newX = robot.x;
    let newY = robot.y;

    if (direction === 'up' && robot.y > 0) newY--;
    else if (direction === 'down' && robot.y < gridSize - 1) newY++;
    else if (direction === 'left' && robot.x > 0) newX--;
    else if (direction === 'right' && robot.x < gridSize - 1) newX++;
    else if (direction === 'up-left' && robot.y > 0 && robot.x > 0 && diagonalMovementEnabled) {
        newY--; newX--;
    }
    else if (direction === 'up-right' && robot.y > 0 && robot.x < gridSize - 1 && diagonalMovementEnabled) {
        newY--; newX++;
    }
    else if (direction === 'down-left' && robot.y < gridSize - 1 && robot.x > 0 && diagonalMovementEnabled) {
        newY++; newX--;
    }
    else if (direction === 'down-right' && robot.y < gridSize - 1 && robot.x < gridSize - 1 && diagonalMovementEnabled) {
        newY++; newX++;
    }
    else {
        addLogEntry('Cannot move in that direction');
        return;
    }

    // Check if target tile is revealed but is an obstacle
    if (grid[newY][newX].revealed && grid[newY][newX].type === 'obstacle') {
        // Check for terraform ability to convert obstacles
        const terraformTech = TECH_TREE.find(t => t.id === "planetary_terraforming" && t.unlocked);
        if (terraformTech) {
            const obstacleEffect = terraformTech.effects.find(e => e.type === "obstacle_conversion");
            
            if (obstacleEffect && obstacleEffect.value === true) {
                // Can convert obstacle - but costs double energy
                energyCost *= 2;
                
                if (robot.energy < energyCost) {
                    addLogEntry('Insufficient energy to terraform obstacle');
                    return;
                }
                
                // Mark that we're terraforming
                robot.terraforming = true;
                addLogEntry('Terraforming obstacle...');
            } else {
                // NEW: Just reveal the tile but don't move there
                if (!grid[newY][newX].revealed) {
                    revealTile(newX, newY);
                    
                    // Consume energy for revealing
                    robot.energy -= Math.round(energyCost * 0.5); // Half energy cost for just revealing
                    addLogEntry(`Path blocked by obstacle at (${newX}, ${newY}). Tile revealed.`);
                    
                    updateUI();
                    drawGrid();
                    return;
                } else {
                    addLogEntry('Path blocked by obstacle');
                    return;
                }
            }
        } else {
            // NEW: Just reveal the tile but don't move there
            if (!grid[newY][newX].revealed) {
                revealTile(newX, newY);
                
                // Consume energy for revealing
                robot.energy -= Math.round(energyCost * 0.5); // Half energy cost for just revealing
                addLogEntry(`Path blocked by obstacle at (${newX}, ${newY}). Tile revealed.`);
                
                updateUI();
                drawGrid();
                return;
            } else {
                addLogEntry('Path blocked by obstacle');
                return;
            }
        }
    }
    
    // NEW: For unexplored tiles, check if it's an obstacle after revealing
    if (!grid[newY][newX].revealed) {
        // Store if it's an obstacle for later use
        const willReveal = true;
        const isObstacle = grid[newY][newX].type === 'obstacle';
        
        // First reveal the tile
        revealTile(newX, newY);
        
        // If it's an obstacle, don't move there
        if (isObstacle) {
            // Consume energy for revealing
            robot.energy -= Math.round(energyCost * 0.5); // Half energy cost for just revealing
            addLogEntry(`Path blocked by obstacle at (${newX}, ${newY}). Tile revealed.`);
            
            updateUI();
            drawGrid();
            return;
        }
    }
    
    // Store last action for potential time reversal
    robot.lastAction = {
        type: "move",
        fromX: robot.x,
        fromY: robot.y,
        toX: newX,
        toY: newY,
        energy: robot.energy,
        revealed: grid[newY][newX].revealed,
        scanned: grid[newY][newX].scanned
    };

    // Set robot to busy state
    robot.busy = true;
    robot.currentAction = robot.terraforming ? "Terraforming" : "Moving";
    robot.actionTimeRemaining = 1 * getUpgradeEffect("speed", "movement"); // Movement takes 1 second, modified by upgrades
    robot.actionProgress = 0;

    // Store target position
    robot.targetX = newX;
    robot.targetY = newY;

    // Play sound effect
    playSoundEffect('move');

    // Start the action
    startAction(() => {
        // Move robot after action completes
        robot.x = robot.targetX;
        robot.y = robot.targetY;
        robot.energy -= Math.round(energyCost);
        robot.actionsPerformed++;
        
        // If we were terraforming, convert the obstacle to empty tile
        if (robot.terraforming) {
            grid[robot.y][robot.x].type = 'empty';
            addLogEntry('Obstacle successfully terraformed!');
            robot.terraforming = false;
        } else {
            addLogEntry(`Moved to position (${robot.x}, ${robot.y})`);
        }

        // Reveal the tile we moved to (in case it wasn't already revealed)
        revealTile(robot.x, robot.y);

        // Check for auto-scan from upgrades
        if (checkAutoScan()) {
            addLogEntry("Auto-scanner detected nearby objects");
        }

        updateUI();
        drawGrid();

        // Check if energy is depleted
        if (robot.energy <= 0) {
            gameOver();
        }
    });
}

        function harvestResource() {
            // Base energy cost
            let energyCost = 5;

            // Apply efficiency upgrades
            energyCost *= getUpgradeEffect("efficiency", "energy");

            // Apply weather penalty if applicable
            if (currentWeather && currentWeather.effect && 
                currentWeather.effect.type === "harvest_penalty") {
                energyCost /= currentWeather.effect.value; // Higher cost
            }

            if (!gameActive) {
                addLogEntry('Mission not active');
                return;
            }

            if (robot.busy) {
                addLogEntry('Robot is busy with another action');
                return;
            }

            if (robot.energy < energyCost) {
                addLogEntry('Insufficient energy for harvesting');
                return;
            }

            const tile = grid[robot.y][robot.x];

            if (!tile.revealed) {
                addLogEntry('Cannot harvest from unrevealed tile');
                return;
            }

            if (tile.type !== 'minerals' && tile.type !== 'crystals' && tile.type !== 'exotic') {
                addLogEntry('No resources to harvest on this tile');
                return;
            }
            
            // Store last action for potential time reversal
            robot.lastAction = {
                type: "harvest",
                x: robot.x,
                y: robot.y,
                tileType: tile.type,
                tileVariant: tile.variant,
                energy: robot.energy,
                minerals: robot.minerals,
                crystals: robot.crystals,
                exotic: robot.exotic
            };

            // Set robot to busy state - harvesting takes longer
            robot.busy = true;
            robot.currentAction = "Harvesting";
            robot.actionTimeRemaining = 3 * getUpgradeEffect("speed", "harvest"); // Harvesting takes 3 seconds, modified by upgrades
            robot.actionProgress = 0;

            // Store resource type
            robot.harvestingType = tile.type;
            robot.harvestingVariant = tile.variant;

            // Play sound effect
            playSoundEffect('harvest');

            // Start the action
            startAction(() => {
                // Complete harvesting after action finishes
                let amount = 1;

                // Check for resource conservation from Cosmic Harmonization
                const cosmicTech = TECH_TREE.find(t => t.id === "cosmic_harmonization" && t.unlocked);
                let resourceConserved = false;
                
                if (cosmicTech) {
                    const conservationEffect = cosmicTech.effects.find(e => e.type === "resource_conservation");
                    if (conservationEffect && Math.random() < conservationEffect.value) {
                        resourceConserved = true;
                    }
                }
                
                // Check if using energy is conserved by Quantum Computing
                let energyConserved = false;
                const quantumTech = TECH_TREE.find(t => t.id === "quantum_computing" && t.unlocked);
                
                if (quantumTech) {
                    const energyEffect = quantumTech.effects.find(e => e.type === "energy_conservation");
                    if (energyEffect && Math.random() < energyEffect.value) {
                        energyConserved = true;
                    }
                }

                if (robot.harvestingType === 'minerals') {
                    // Variant 2 gives double minerals
                    if (robot.harvestingVariant === 2) amount = 2;

                    // Check for bonus from weather or upgrades
                    amount += checkResourceBonus('minerals');

                    robot.minerals += amount;
                    totalResources += amount;
                    
                    if (!resourceConserved) {
                        tile.type = 'empty';
                    }
                    
                    addLogEntry(`Harvested ${amount} minerals${resourceConserved ? ' (Resource conserved!)' : ''}`);

                    // Check for resource collection side missions
                    checkSideMissionProgress("collect", { resourceType: "minerals", amount });

                } else if (robot.harvestingType === 'crystals') {
                    // Check for crystal boost from weather
                    if (currentWeather && currentWeather.effect && 
                        currentWeather.effect.type === "crystal_boost") {
                        amount = Math.ceil(amount * currentWeather.effect.value);
                    }

                    // Check for bonus from upgrades
                    amount += checkResourceBonus('crystals');
                    
                    // Check for yield bonus from crystal relic
                    const crystalRelic = discoveredRelics.find(r => r.effect.type === "crystal_yield");
                    if (crystalRelic) {
                        amount = Math.ceil(amount * crystalRelic.effect.value);
                    }

                    robot.crystals += amount;
                    totalResources += amount;
                    
                    if (!resourceConserved) {
                        tile.type = 'empty';
                    }
                    
                    addLogEntry(`Harvested ${amount} crystals${resourceConserved ? ' (Resource conserved!)' : ''}`);

                    // Check for resource collection side missions
                    checkSideMissionProgress("collect", { resourceType: "crystals", amount });
                    
                    // Update achievement progress
                    updateAchievementProgress("crystal_connoisseur", amount);
                    
                } else if (robot.harvestingType === 'exotic') {
                    // Check for exotic boost from weather
                    if (currentWeather && currentWeather.effect && 
                        currentWeather.effect.type === "exotic_boost") {
                        amount = Math.ceil(amount * currentWeather.effect.value);
                    }
                    
                    // Check for bonus from upgrades
                    amount += checkResourceBonus('exotic');
                    
                    // Check for yield bonus from void shard relic
                    const voidRelic = discoveredRelics.find(r => r.effect.type === "exotic_yield");
                    if (voidRelic) {
                        amount = Math.ceil(amount * voidRelic.effect.value);
                    }
                    
                    robot.exotic += amount;
                    totalResources += amount;
                    totalExoticCollected += amount;
                    
                    if (!resourceConserved) {
                        tile.type = 'empty';
                    }
                    
                    addLogEntry(`Harvested ${amount} exotic materials${resourceConserved ? ' (Resource conserved!)' : ''}`);
                    
                    // Check for resource collection side missions
                    checkSideMissionProgress("collect", { resourceType: "exotic", amount });
                    
                    // Update achievement progress
                    updateAchievementProgress("exotic_explorer", amount);
                }

                if (!energyConserved) {
                    robot.energy -= Math.round(energyCost);
                } else {
                    addLogEntry("Quantum fluctuation conserved energy during harvesting!");
                }
                
                robot.actionsPerformed++;

                updateUI();
                drawGrid();
                updateObjectiveDisplay();
                saveGameData();

                // Check if energy is depleted
                if (robot.energy <= 0) {
                    gameOver();
                }
                
                // Check for repeating action from temporal lens relic
                const temporalRelic = discoveredRelics.find(r => r.effect.type === "action_repeat");
                if (temporalRelic && Math.random() < temporalRelic.effect.value) {
                    // Only repeat if there's still a resource to harvest
                    if (grid[robot.y][robot.x].type === robot.harvestingType) {
                        addLogEntry("Temporal lens activated! Action repeating without energy cost...");
                        
                        // Set a timeout to wait a moment before repeating
                        setTimeout(() => {
                            // Repeat the harvest but don't spend energy
                            const originalEnergyCost = energyCost;
                            energyCost = 0;
                            harvestResource();
                            energyCost = originalEnergyCost;
                        }, 500);
                    }
                }
            });
        }
        
// ==========================================
// ENHANCEMENT: Carrying Capacity System
// ==========================================
// This adds resource slots to the robot and requires returning resources to base

// 1. Add carrying capacity properties to the robot
function addCarryingCapacity() {
    // Add these properties to the robot object initialization
    robot.carryingCapacity = 3; // Maximum number of resource slots
    robot.carryingAmount = 0;   // Current number of filled slots
    robot.inventoryDisplay = []; // Visual representation of inventory
    
    // Update UI to show inventory
    addInventoryDisplay();
}

// 2. Create UI elements for inventory display
function addInventoryDisplay() {
    // Create the HTML elements to add
    const inventoryHTML = `
    <div class="inventory-container">
        <div class="inventory-title">Cargo Slots: <span id="cargoCount">0</span>/<span id="cargoCapacity">3</span></div>
        <div class="inventory-slots" id="inventorySlots">
            <div class="inventory-slot empty"></div>
            <div class="inventory-slot empty"></div>
            <div class="inventory-slot empty"></div>
        </div>
    </div>
    `;
    
    // Add CSS for inventory
    const inventoryCSS = `
    .inventory-container {
        background-color: rgba(40, 60, 80, 0.6);
        border-radius: 5px;
        padding: 0.75rem;
        margin: 0.5rem 0;
        border: 1px solid rgba(64, 170, 255, 0.4);
    }
    
    .inventory-title {
        margin-bottom: 0.5rem;
        display: flex;
        justify-content: space-between;
    }
    
    .inventory-slots {
        display: flex;
        justify-content: space-between;
        gap: 0.5rem;
    }
    
    .inventory-slot {
        width: 40px;
        height: 40px;
        border-radius: 5px;
        border: 1px solid rgba(64, 170, 255, 0.4);
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 1.2rem;
        background-color: rgba(30, 40, 60, 0.7);
        position: relative;
    }
    
    .inventory-slot.empty {
        opacity: 0.5;
    }
    
    .inventory-slot.minerals {
        background-color: rgba(100, 240, 100, 0.3);
    }
    
    .inventory-slot.crystals {
        background-color: rgba(240, 100, 240, 0.3);
    }
    
    .inventory-slot.exotic {
        background-color: rgba(180, 100, 255, 0.3);
    }
    
    .inventory-slot::after {
        position: absolute;
        bottom: 2px;
        right: 2px;
        font-size: 0.7rem;
        color: white;
    }
    
    .inventory-slot.minerals::after {
        content: 'üî∑';
    }
    
    .inventory-slot.crystals::after {
        content: 'üíé';
    }
    
    .inventory-slot.exotic::after {
        content: 'üß™';
    }
    `;
    
    // Function to insert this UI into the game
    // This should be inserted in the UI div, after the resources section
    const resourcesElement = document.querySelector('.resources');
    if (resourcesElement) {
        // Create a style element for the CSS
        const styleElement = document.createElement('style');
        styleElement.textContent = inventoryCSS;
        document.head.appendChild(styleElement);
        
        // Create a div for the inventory
        const inventoryContainer = document.createElement('div');
        inventoryContainer.innerHTML = inventoryHTML;
        
        // Insert after resources
        resourcesElement.parentNode.insertBefore(inventoryContainer, resourcesElement.nextSibling);
    }
}

// 3. Modified harvestResource function to use carrying capacity
function harvestResourceWithCarrying() {
    // Base energy cost
    let energyCost = 5;

    // Apply efficiency upgrades
    energyCost *= getUpgradeEffect("efficiency", "energy");

    // Apply weather penalty if applicable
    if (currentWeather && currentWeather.effect && 
        currentWeather.effect.type === "harvest_penalty") {
        energyCost /= currentWeather.effect.value; // Higher cost
    }

    if (!gameActive) {
        addLogEntry('Mission not active');
        return;
    }

    if (robot.busy) {
        addLogEntry('Robot is busy with another action');
        return;
    }

    if (robot.energy < energyCost) {
        addLogEntry('Insufficient energy for harvesting');
        return;
    }

    // Check if inventory is full
    if (robot.carryingAmount >= robot.carryingCapacity) {
        addLogEntry('Cargo slots full. Return to base to deposit resources.');
        return;
    }

    const tile = grid[robot.y][robot.x];

    if (!tile.revealed) {
        addLogEntry('Cannot harvest from unrevealed tile');
        return;
    }

    if (tile.type !== 'minerals' && tile.type !== 'crystals' && tile.type !== 'exotic') {
        addLogEntry('No resources to harvest on this tile');
        return;
    }
    
    // Store last action for potential time reversal
    robot.lastAction = {
        type: "harvest",
        x: robot.x,
        y: robot.y,
        tileType: tile.type,
        tileVariant: tile.variant,
        energy: robot.energy,
        carryingAmount: robot.carryingAmount,
        inventoryDisplay: [...robot.inventoryDisplay]
    };

    // Set robot to busy state - harvesting takes longer
    robot.busy = true;
    robot.currentAction = "Harvesting";
    robot.actionTimeRemaining = 3 * getUpgradeEffect("speed", "harvest"); // Harvesting takes 3 seconds, modified by upgrades
    robot.actionProgress = 0;

    // Store resource type
    robot.harvestingType = tile.type;
    robot.harvestingVariant = tile.variant;

    // Play sound effect
    playSoundEffect('harvest');

    // Start the action
    startAction(() => {
        // Complete harvesting after action finishes
        let amount = 1; // One slot per harvest

        // Check for resource conservation from Cosmic Harmonization
        const cosmicTech = TECH_TREE.find(t => t.id === "cosmic_harmonization" && t.unlocked);
        let resourceConserved = false;
        
        if (cosmicTech) {
            const conservationEffect = cosmicTech.effects.find(e => e.type === "resource_conservation");
            if (conservationEffect && Math.random() < conservationEffect.value) {
                resourceConserved = true;
            }
        }
        
        // Check if using energy is conserved by Quantum Computing
        let energyConserved = false;
        const quantumTech = TECH_TREE.find(t => t.id === "quantum_computing" && t.unlocked);
        
        if (quantumTech) {
            const energyEffect = quantumTech.effects.find(e => e.type === "energy_conservation");
            if (energyEffect && Math.random() < energyEffect.value) {
                energyConserved = true;
            }
        }

        // Add to carrying inventory rather than directly to resources
        robot.carryingAmount += amount;
        robot.inventoryDisplay.push(robot.harvestingType);
        
        // Clear the tile if not conserved
        if (!resourceConserved) {
            tile.type = 'empty';
        }
        
        // Report what was harvested
        addLogEntry(`Harvested ${amount} ${robot.harvestingType} (Cargo slots: ${robot.carryingAmount}/${robot.carryingCapacity})${resourceConserved ? ' (Resource conserved!)' : ''}`);

        // Track progress for side missions
        checkSideMissionProgress("collect", { resourceType: robot.harvestingType, amount });
        
        // Track achievements
        if (robot.harvestingType === 'crystals') {
            updateAchievementProgress("crystal_connoisseur", amount);
        } else if (robot.harvestingType === 'exotic') {
            updateAchievementProgress("exotic_explorer", amount);
        }

        // Apply energy cost
        if (!energyConserved) {
            robot.energy -= Math.round(energyCost);
        } else {
            addLogEntry("Quantum fluctuation conserved energy during harvesting!");
        }
        
        robot.actionsPerformed++;

        // Update UI
        updateInventoryDisplay();
        updateUI();
        drawGrid();
        updateObjectiveDisplay();
        saveGameData();

        // Check if energy is depleted
        if (robot.energy <= 0) {
            gameOver();
        }
    });
}

// 4. Function to update the inventory display
function updateInventoryDisplay() {
    const inventorySlotsElement = document.getElementById('inventorySlots');
    const cargoCountElement = document.getElementById('cargoCount');
    const cargoCapacityElement = document.getElementById('cargoCapacity');
    
    if (!inventorySlotsElement || !cargoCountElement || !cargoCapacityElement) return;
    
    // Update count display
    cargoCountElement.textContent = robot.carryingAmount;
    cargoCapacityElement.textContent = robot.carryingCapacity;
    
    // Clear slots
    inventorySlotsElement.innerHTML = '';
    
    // Populate slots with current inventory
    for (let i = 0; i < robot.carryingCapacity; i++) {
        const slotElement = document.createElement('div');
        slotElement.className = 'inventory-slot';
        
        if (i < robot.inventoryDisplay.length) {
            // Filled slot
            slotElement.classList.add(robot.inventoryDisplay[i]);
            slotElement.textContent = getResourceIcon(robot.inventoryDisplay[i]);
        } else {
            // Empty slot
            slotElement.classList.add('empty');
        }
        
        inventorySlotsElement.appendChild(slotElement);
    }
}

// Helper function to get resource icon
function getResourceIcon(resourceType) {
    switch (resourceType) {
        case 'minerals': return 'üî∑';
        case 'crystals': return 'üíé';
        case 'exotic': return 'üß™';
        default: return '';
    }
}

// 5. Function to deposit resources at base
function depositResources() {
    if (!gameActive) {
        addLogEntry('Mission not active');
        return;
    }

    if (robot.busy) {
        addLogEntry('Robot is busy with another action');
        return;
    }

    // Check if at base
    if (!robot.hasBase || robot.x !== robot.baseLocation.x || robot.y !== robot.baseLocation.y) {
        addLogEntry('Must be at base location to deposit resources');
        return;
    }

    // Check if carrying anything
    if (robot.carryingAmount === 0) {
        addLogEntry('No resources to deposit');
        return;
    }
    
    // Store last action for potential time reversal
    robot.lastAction = {
        type: "deposit",
        x: robot.x,
        y: robot.y,
        energy: robot.energy,
        minerals: robot.minerals,
        crystals: robot.crystals,
        exotic: robot.exotic,
        carryingAmount: robot.carryingAmount,
        inventoryDisplay: [...robot.inventoryDisplay]
    };

    // Set robot to busy state
    robot.busy = true;
    robot.currentAction = "Depositing Resources";
    robot.actionTimeRemaining = 2 * getUpgradeEffect("speed", "build"); // Depositing takes 2 seconds
    robot.actionProgress = 0;

    // Play sound effect (could use build sound)
    playSoundEffect('build');

    // Start the action
    startAction(() => {
        // Count resources by type
        const resourceCounts = {
            minerals: 0,
            crystals: 0,
            exotic: 0
        };
        
        // Count each resource type
        for (const resource of robot.inventoryDisplay) {
            resourceCounts[resource]++;
        }
        
        // Add resources to robot's inventory
        robot.minerals += resourceCounts.minerals;
        robot.crystals += resourceCounts.crystals;
        robot.exotic += resourceCounts.exotic;
        
        // Update total resources for tracking
        totalResources += robot.carryingAmount;
        totalExoticCollected += resourceCounts.exotic;
        
        // Clear carried resources
        robot.carryingAmount = 0;
        robot.inventoryDisplay = [];
        
        // Log the deposit
        let depositMessage = 'Deposited resources at base: ';
        let resourcesDeposited = [];
        
        if (resourceCounts.minerals > 0) resourcesDeposited.push(`${resourceCounts.minerals} minerals`);
        if (resourceCounts.crystals > 0) resourcesDeposited.push(`${resourceCounts.crystals} crystals`);
        if (resourceCounts.exotic > 0) resourcesDeposited.push(`${resourceCounts.exotic} exotic materials`);
        
        depositMessage += resourcesDeposited.join(', ');
        addLogEntry(depositMessage);
        
        // Update UI
        updateInventoryDisplay();
        updateUI();
        updateObjectiveDisplay();
        saveGameData();
    });
}

// 6. Modified buildBase function to work with carrying capacity
function buildBaseWithCarrying() {
    let mineralCost = 3;
    const energyBonus = 30; // Energy gained from building a base
    
    // Check for reduced cost from tech tree
    const mineralTech = TECH_TREE.find(t => t.id === "mineral_processing" && t.unlocked);
    if (mineralTech) {
        const costEffect = mineralTech.effects.find(e => e.type === "reduced_cost" && e.target === "base");
        if (costEffect) {
            mineralCost = costEffect.value;
        }
    }
    
    // Check for construction discount from architect's cipher relic
    const architectRelic = discoveredRelics.find(r => r.effect.type === "construction_discount");
    if (architectRelic) {
        mineralCost = Math.max(1, mineralCost - architectRelic.effect.value);
    }
    
    // Check for side mission that requires efficient construction
    const efficientMission = activeSideMissions.find(
        m => m.parameters.type === "efficient_construction" && !m.completed
    );
    
    if (efficientMission) {
        // This mission requires using fewer minerals
        mineralCost = efficientMission.parameters.target;
    }

    if (!gameActive) {
        addLogEntry('Mission not active');
        return;
    }

    if (robot.busy) {
        addLogEntry('Robot is busy with another action');
        return;
    }

    if (robot.minerals < mineralCost) {
        addLogEntry(`Insufficient minerals for base construction (need ${mineralCost})`);
        return;
    }

    const tile = grid[robot.y][robot.x];

    if (!tile.revealed) {
        addLogEntry('Cannot build on unrevealed tile');
        return;
    }

    if (tile.type !== 'empty') {
        addLogEntry('Cannot build on non-empty tile');
        return;
    }

    if (robot.hasBase) {
        addLogEntry('Base already constructed');
        return;
    }
    
    // Store last action for potential time reversal
    robot.lastAction = {
        type: "build_base",
        x: robot.x,
        y: robot.y,
        energy: robot.energy,
        minerals: robot.minerals,
        hasBase: false
    };

    // Set robot to busy state - base construction takes longer
    robot.busy = true;
    robot.currentAction = "Building Base";
    robot.actionTimeRemaining = 5 * getUpgradeEffect("speed", "build"); // Base building takes 5 seconds, modified by upgrades
    robot.actionProgress = 0;

    // Play sound effect
    playSoundEffect('build');

    // Start the action
    startAction(() => {
        // Complete base construction after action finishes
        tile.type = 'base';
        robot.minerals -= mineralCost;
        robot.hasBase = true;
        robot.baseLocation = { x: robot.x, y: robot.y };
        robot.actionsPerformed++;

        // Track total bases built for achievements
        basesBuilt++;
        
        // Update achievement progress
        updateAchievementProgress("base_builder", 1);

        // Grant energy bonus for building base
        robot.energy = Math.min(robot.maxEnergy, robot.energy + energyBonus);

        addLogEntry('Base constructed successfully!');
        addLogEntry(`Power core activated: +${energyBonus} energy`);
        addLogEntry('Now gather resources to build the ship');
        
        // Check for efficient construction side mission
        if (efficientMission) {
            completeSideMission(efficientMission);
        }

        updateUI();
        drawGrid();
        updateObjectiveDisplay();
        saveGameData();
    });
}

// 7. Modified constructShip function to work with carrying capacity
function constructShipWithCarrying() {
    let mineralCost = 5;
    let crystalCost = 2;
    
    // Check for reduced costs from tech tree
    const crystalTech = TECH_TREE.find(t => t.id === "crystal_harmonics" && t.unlocked);
    if (crystalTech) {
        const costEffect = crystalTech.effects.find(e => e.type === "reduced_cost" && e.target === "ship");
        if (costEffect) {
            crystalCost = costEffect.value;
        }
    }
    
    // Check for construction discount from architect's cipher relic
    const architectRelic = discoveredRelics.find(r => r.effect.type === "construction_discount");
    if (architectRelic) {
        mineralCost = Math.max(1, mineralCost - architectRelic.effect.value);
        crystalCost = Math.max(1, crystalCost - architectRelic.effect.value);
    }

    if (!gameActive) {
        addLogEntry('Mission not active');
        return;
    }

    if (robot.busy) {
        addLogEntry('Robot is busy with another action');
        return;
    }

    if (!robot.hasBase) {
        addLogEntry('Must build a base before constructing ship');
        return;
    }

    if (robot.minerals < mineralCost || robot.crystals < crystalCost) {
        addLogEntry(`Insufficient resources for ship construction (need ${mineralCost} minerals, ${crystalCost} crystals)`);
        return;
    }

    // Check if robot is at base location
    if (robot.x !== robot.baseLocation.x || robot.y !== robot.baseLocation.y) {
        addLogEntry('Must be at base location to construct ship');
        return;
    }
    
    // Store last action for potential time reversal
    robot.lastAction = {
        type: "build_ship",
        x: robot.x,
        y: robot.y,
        energy: robot.energy,
        minerals: robot.minerals,
        crystals: robot.crystals,
        hasBase: true,
        shipConstructed: false
    };

    // Set robot to busy state - ship construction takes the longest
    robot.busy = true;
    robot.currentAction = "Constructing Ship";
    robot.actionTimeRemaining = 8 * getUpgradeEffect("speed", "build"); // Ship construction takes 8 seconds, modified by upgrades
    robot.actionProgress = 0;

    // Play sound effect
    playSoundEffect('build');

    // Start the action
    startAction(() => {
        // Complete ship construction after action finishes
        const tile = grid[robot.y][robot.x];
        tile.type = 'ship';
        robot.minerals -= mineralCost;
        robot.crystals -= crystalCost;
        robot.shipConstructed = true;
        robot.actionsPerformed++;

        addLogEntry('Ship constructed successfully!');

        updateUI();
        drawGrid();
        updateObjectiveDisplay();

        // Trigger mission completion after a short delay
        setTimeout(() => {
            playSoundEffect('launch');
            completeMission();
        }, 1500);
    });
}

// 8. Update to the helper updateButtonStates function to account for carrying capacity
function updateButtonStatesWithCarrying() {
    const scanBtn = document.getElementById('scanBtn');
    const buildBaseBtn = document.getElementById('buildBaseBtn');
    const harvestBtn = document.getElementById('harvestBtn');
    const constructShipBtn = document.getElementById('constructShipBtn');
    const depositBtn = document.getElementById('depositBtn'); // New deposit button

    // Movement buttons
    const moveUpBtn = document.getElementById('moveUpBtn');
    const moveDownBtn = document.getElementById('moveDownBtn');
    const moveLeftBtn = document.getElementById('moveLeftBtn');
    const moveRightBtn = document.getElementById('moveRightBtn');

    // If game not active or robot is busy, disable all action buttons
    if (!gameActive || robot.busy) {
        scanBtn.disabled = true;
        buildBaseBtn.disabled = true;
        harvestBtn.disabled = true;
        constructShipBtn.disabled = true;
        depositBtn.disabled = true;
        moveUpBtn.disabled = true;
        moveDownBtn.disabled = true;
        moveLeftBtn.disabled = true;
        moveRightBtn.disabled = true;
        return;
    }

    // Base energy costs
    let scanEnergyCost = 3;
    let moveEnergyCost = 3;
    let harvestEnergyCost = 5;

    // Apply upgrades
    scanEnergyCost *= getUpgradeEffect("efficiency", "energy");
    moveEnergyCost *= getUpgradeEffect("efficiency", "movement");
    harvestEnergyCost *= getUpgradeEffect("efficiency", "energy");

    // Apply weather effects
    if (currentWeather && currentWeather.effect) {
        if (currentWeather.effect.type === "scan_penalty") {
            scanEnergyCost /= currentWeather.effect.value; // Higher cost
        } else if (currentWeather.effect.type === "harvest_penalty") {
            harvestEnergyCost /= currentWeather.effect.value; // Higher cost
        } else if (currentWeather.effect.type === "energy_drain") {
            // This is applied in the energy drain timer
        }
    }

    // Round costs to whole numbers for display
    scanEnergyCost = Math.round(scanEnergyCost);
    moveEnergyCost = Math.round(moveEnergyCost);
    harvestEnergyCost = Math.round(harvestEnergyCost);

    // Update button text with costs
    scanBtn.textContent = `Scan Tile (‚ö°${scanEnergyCost})`;
    harvestBtn.textContent = `Harvest (‚ö°${harvestEnergyCost})`;

    // Scan button
    scanBtn.disabled = robot.energy < scanEnergyCost || grid[robot.y][robot.x].revealed;
                
    // Get mineral cost for base
    let mineralCost = 3;
    const mineralTech = TECH_TREE.find(t => t.id === "mineral_processing" && t.unlocked);
    if (mineralTech) {
        const costEffect = mineralTech.effects.find(e => e.type === "reduced_cost" && e.target === "base");
        if (costEffect) {
            mineralCost = costEffect.value;
        }
    }
    
    // Check for side mission that requires efficient construction
    const efficientMission = activeSideMissions.find(
        m => m.parameters.type === "efficient_construction" && !m.completed
    );
    
    if (efficientMission) {
        mineralCost = efficientMission.parameters.target;
    }

    // Build base button
    buildBaseBtn.disabled = robot.minerals < mineralCost ||
        robot.hasBase ||
        !grid[robot.y][robot.x].revealed ||
        grid[robot.y][robot.x].type !== 'empty';
                
    // Update button text with cost
    buildBaseBtn.textContent = `Build Base (üî∑${mineralCost})`;
    
    // Get ship costs
    let shipMineralCost = 5;
    let shipCrystalCost = 2;
    
    // Apply tech tree reductions
    const crystalTech = TECH_TREE.find(t => t.id === "crystal_harmonics" && t.unlocked);
    if (crystalTech) {
        const costEffect = crystalTech.effects.find(e => e.type === "reduced_cost" && e.target === "ship");
        if (costEffect) {
            shipCrystalCost = costEffect.value;
        }
    }
    
    // Update ship button text
    constructShipBtn.textContent = `Launch Ship (üî∑${shipMineralCost}, üíé${shipCrystalCost})`;

    // Harvest button - check cargo capacity
    harvestBtn.disabled = robot.energy < harvestEnergyCost ||
        !grid[robot.y][robot.x].revealed ||
        !['minerals', 'crystals', 'exotic'].includes(grid[robot.y][robot.x].type) ||
        robot.carryingAmount >= robot.carryingCapacity;

    // Construct ship button
    constructShipBtn.disabled = !robot.hasBase ||
        robot.minerals < shipMineralCost ||
        robot.crystals < shipCrystalCost ||
        robot.x !== robot.baseLocation.x ||
        robot.y !== robot.baseLocation.y;
        
    // Deposit button - enabled when at base with resources to deposit
    depositBtn.disabled = !robot.hasBase ||
        robot.x !== robot.baseLocation.x ||
        robot.y !== robot.baseLocation.y ||
        robot.carryingAmount === 0;

    // Movement buttons - support diagonal movement if enabled
    // Check if we can move in each direction and if the tile is not an obstacle
    const canMoveUp = robot.y > 0 && robot.energy >= moveEnergyCost &&
        (!grid[robot.y - 1][robot.x].revealed || grid[robot.y - 1][robot.x].type !== 'obstacle');
                
    const canMoveDown = robot.y < gridSize - 1 && robot.energy >= moveEnergyCost &&
        (!grid[robot.y + 1][robot.x].revealed || grid[robot.y + 1][robot.x].type !== 'obstacle');
                
    const canMoveLeft = robot.x > 0 && robot.energy >= moveEnergyCost &&
        (!grid[robot.y][robot.x - 1].revealed || grid[robot.y][robot.x - 1].type !== 'obstacle');
                
    const canMoveRight = robot.x < gridSize - 1 && robot.energy >= moveEnergyCost &&
        (!grid[robot.y][robot.x + 1].revealed || grid[robot.y][robot.x + 1].type !== 'obstacle');
                
    moveUpBtn.disabled = !canMoveUp;
    moveDownBtn.disabled = !canMoveDown;
    moveLeftBtn.disabled = !canMoveLeft;
    moveRightBtn.disabled = !canMoveRight;
    
    // If diagonal movement is enabled, update those buttons too
    if (diagonalMovementEnabled) {
        // Handle diagonal movement buttons...
        const moveUpLeftBtn = document.getElementById('moveUpLeftBtn');
        const moveUpRightBtn = document.getElementById('moveUpRightBtn');
        const moveDownLeftBtn = document.getElementById('moveDownLeftBtn');
        const moveDownRightBtn = document.getElementById('moveDownRightBtn');
        
        if (moveUpLeftBtn && moveUpRightBtn && moveDownLeftBtn && moveDownRightBtn) {
            const canMoveUpLeft = canMoveUp && canMoveLeft;
            const canMoveUpRight = canMoveUp && canMoveRight;
            const canMoveDownLeft = canMoveDown && canMoveLeft;
            const canMoveDownRight = canMoveDown && canMoveRight;
            
            moveUpLeftBtn.disabled = !canMoveUpLeft;
            moveUpRightBtn.disabled = !canMoveUpRight;
            moveDownLeftBtn.disabled = !canMoveDownLeft;
            moveDownRightBtn.disabled = !canMoveDownRight;
        }
    }
}

// 9. Initialize the carrying capacity system
function initializeCarryingCapacitySystem() {
    // Add carrying capacity properties
    //addCarryingCapacity();
    
    // Add deposit button to UI
    const controlPanel = document.querySelector('.control-panel');
    if (controlPanel) {
        const depositBtn = document.createElement('button');
        depositBtn.id = 'depositBtn';
        depositBtn.textContent = 'Deposit Resources';
        depositBtn.onclick = depositResources;
        controlPanel.appendChild(depositBtn);
    }
    
    // Replace the existing functions with the carrying capacity versions
    window.harvestResource = harvestResourceWithCarrying;
    window.buildBase = buildBaseWithCarrying;
    window.constructShip = constructShipWithCarrying;
    
    // Update the UI function to include inventory
    const originalUpdateUI = window.updateUI;
    window.updateUI = function() {
        originalUpdateUI();
        updateInventoryDisplay();
    };
    
    // Update the button states function
    const originalUpdateButtonStates = window.updateButtonStates;
    window.updateButtonStates = function() {
        updateButtonStatesWithCarrying();
    };
    
    // Update startNewMission to reset inventory
    const originalStartNewMission = window.startNewMission;
    window.startNewMission = function(startActive = true) {
        originalStartNewMission(startActive);
        robot.carryingAmount = 0;
        robot.inventoryDisplay = [];
        updateInventoryDisplay();
    };
    
    // Add log entry about carrying capacity
    addLogEntry('Robot carrying capacity system initialized: 3 resource slots available');
}

// Function to apply the CSS fixes
function applyTechTooltipFix() {
    // Create a style element
    const style = document.createElement('style');
    style.textContent = techTooltipCSS;
    document.head.appendChild(style);
}

// Apply the fixes
// Apply the tech tooltip fix
applyTechTooltipFix();

// Replace the scanTile function
window.scanTile = scanTile;

// Implement the carrying capacity system
initializeCarryingCapacitySystem();  // Now enabenab

        function buildBase() {
            let mineralCost = 3;
            const energyBonus = 30; // Energy gained from building a base
            
            // Check for reduced cost from tech tree
            const mineralTech = TECH_TREE.find(t => t.id === "mineral_processing" && t.unlocked);
            if (mineralTech) {
                const costEffect = mineralTech.effects.find(e => e.type === "reduced_cost" && e.target === "base");
                if (costEffect) {
                    mineralCost = costEffect.value;
                }
            }
            
            // Check for construction discount from architect's cipher relic
            const architectRelic = discoveredRelics.find(r => r.effect.type === "construction_discount");
            if (architectRelic) {
                mineralCost = Math.max(1, mineralCost - architectRelic.effect.value);
            }
            
            // Check for side mission that requires efficient construction
            const efficientMission = activeSideMissions.find(
                m => m.parameters.type === "efficient_construction" && !m.completed
            );
            
            if (efficientMission) {
                // This mission requires using fewer minerals
                mineralCost = efficientMission.parameters.target;
            }

            if (!gameActive) {
                addLogEntry('Mission not active');
                return;
            }

            if (robot.busy) {
                addLogEntry('Robot is busy with another action');
                return;
            }

            if (robot.minerals < mineralCost) {
                addLogEntry(`Insufficient minerals for base construction (need ${mineralCost})`);
                return;
            }

            const tile = grid[robot.y][robot.x];

            if (!tile.revealed) {
                addLogEntry('Cannot build on unrevealed tile');
                return;
            }

            if (tile.type !== 'empty') {
                addLogEntry('Cannot build on non-empty tile');
                return;
            }

            if (robot.hasBase) {
                addLogEntry('Base already constructed');
                return;
            }
            
            // Store last action for potential time reversal
            robot.lastAction = {
                type: "build_base",
                x: robot.x,
                y: robot.y,
                energy: robot.energy,
                minerals: robot.minerals,
                hasBase: false
            };

            // Set robot to busy state - base construction takes longer
            robot.busy = true;
            robot.currentAction = "Building Base";
            robot.actionTimeRemaining = 5 * getUpgradeEffect("speed", "build"); // Base building takes 5 seconds, modified by upgrades
            robot.actionProgress = 0;

            // Play sound effect
            playSoundEffect('build');

            // Start the action
            startAction(() => {
                // Complete base construction after action finishes
                tile.type = 'base';
                robot.minerals -= mineralCost;
                robot.hasBase = true;
                robot.baseLocation = { x: robot.x, y: robot.y };
                robot.actionsPerformed++;

                // Track total bases built for achievements
                basesBuilt++;
                
                // Update achievement progress
                updateAchievementProgress("base_builder", 1);

                // Grant energy bonus for building base
                robot.energy = Math.min(robot.maxEnergy, robot.energy + energyBonus);

                addLogEntry('Base constructed successfully!');
                addLogEntry(`Power core activated: +${energyBonus} energy`);
                addLogEntry('Now gather resources to build the ship');
                
                // Check for efficient construction side mission
                if (efficientMission) {
                    completeSideMission(efficientMission);
                }

                updateUI();
                drawGrid();
                updateObjectiveDisplay();
                saveGameData();
            });
        }

        function constructShip() {
            let mineralCost = 5;
            let crystalCost = 2;
            
            // Check for reduced costs from tech tree
            const crystalTech = TECH_TREE.find(t => t.id === "crystal_harmonics" && t.unlocked);
            if (crystalTech) {
                const costEffect = crystalTech.effects.find(e => e.type === "reduced_cost" && e.target === "ship");
                if (costEffect) {
                    crystalCost = costEffect.value;
                }
            }
            
            // Check for construction discount from architect's cipher relic
            const architectRelic = discoveredRelics.find(r => r.effect.type === "construction_discount");
            if (architectRelic) {
                mineralCost = Math.max(1, mineralCost - architectRelic.effect.value);
                crystalCost = Math.max(1, crystalCost - architectRelic.effect.value);
            }

            if (!gameActive) {
                addLogEntry('Mission not active');
                return;
            }

            if (robot.busy) {
                addLogEntry('Robot is busy with another action');
                return;
            }

            if (!robot.hasBase) {
                addLogEntry('Must build a base before constructing ship');
                return;
            }

            if (robot.minerals < mineralCost || robot.crystals < crystalCost) {
                addLogEntry(`Insufficient resources for ship construction (need ${mineralCost} minerals, ${crystalCost} crystals)`);
                return;
            }

            // Check if robot is at base location
            if (robot.x !== robot.baseLocation.x || robot.y !== robot.baseLocation.y) {
                addLogEntry('Must be at base location to construct ship');
                return;
            }
            
            // Store last action for potential time reversal
            robot.lastAction = {
                type: "build_ship",
                x: robot.x,
                y: robot.y,
                energy: robot.energy,
                minerals: robot.minerals,
                crystals: robot.crystals,
                hasBase: true,
                shipConstructed: false
            };

            // Set robot to busy state - ship construction takes the longest
            robot.busy = true;
            robot.currentAction = "Constructing Ship";
            robot.actionTimeRemaining = 8 * getUpgradeEffect("speed", "build"); // Ship construction takes 8 seconds, modified by upgrades
            robot.actionProgress = 0;

            // Play sound effect
            playSoundEffect('build');

            // Start the action
            startAction(() => {
                // Complete ship construction after action finishes
                const tile = grid[robot.y][robot.x];
                tile.type = 'ship';
                robot.minerals -= mineralCost;
                robot.crystals -= crystalCost;
                robot.shipConstructed = true;
                robot.actionsPerformed++;

                addLogEntry('Ship constructed successfully!');

                updateUI();
                drawGrid();
                updateObjectiveDisplay();

                // Trigger mission completion after a short delay
                setTimeout(() => {
                    playSoundEffect('launch');
                    completeMission();
                }, 1500);
            });
        }
        
        // Teleport to a revealed tile (from cosmic harmonization tech)
        function teleportToTile(x, y) {
            if (!teleportAvailable) {
                addLogEntry('Teleportation not available.');
                return;
            }
            
            if (!gameActive || robot.busy) {
                return;
            }
            
            if (!grid[y] || !grid[y][x]) {
                return;
            }
            
            // Check if tile is revealed
            if (!grid[y][x].revealed) {
                addLogEntry('Cannot teleport to unrevealed location.');
                return;
            }
            
            // Check if tile is an obstacle
            if (grid[y][x].type === 'obstacle') {
                addLogEntry('Cannot teleport into an obstacle.');
                return;
            }
            
            // Store last action for potential time reversal
            robot.lastAction = {
                type: "teleport",
                fromX: robot.x,
                fromY: robot.y,
                toX: x,
                toY: y,
                energy: robot.energy
            };
            
            // Set robot to busy state
            robot.busy = true;
            robot.currentAction = "Teleporting";
            robot.actionTimeRemaining = 3 * getUpgradeEffect("speed", "movement"); // Teleporting takes 3 seconds
            robot.actionProgress = 0;
            
            // Store target position
            robot.targetX = x;
            robot.targetY = y;
            
            // Play sound effect
            playSoundEffect('button_click');
            
            // Start the action
            startAction(() => {
                // Teleport after action completes
                robot.x = robot.targetX;
                robot.y = robot.targetY;
                robot.actionsPerformed++;
                
                // Teleport uses one charge
                teleportAvailable = false;
                
                addLogEntry(`Teleported to position (${robot.x}, ${robot.y})`);
                
                updateUI();
                drawGrid();
            });
        }
        
        // Reverse time to undo the last action
        function reverseTime() {
            if (!timeReversalAvailable) {
                addLogEntry('Time reversal not available.');
                return;
            }
            
            if (!robot.lastAction) {
                addLogEntry('No previous action to reverse.');
                return;
            }
            
            if (!gameActive || robot.busy) {
                return;
            }
            
            // Apply the reversal based on action type
            const lastAction = robot.lastAction;
            
            switch (lastAction.type) {
                case "move":
                    robot.x = lastAction.fromX;
                    robot.y = lastAction.fromY;
                    robot.energy = lastAction.energy;
                    
                    // Restore revealed/scanned state if the tile wasn't previously revealed
                    if (!lastAction.revealed) {
                        grid[lastAction.toY][lastAction.toX].revealed = false;
                        grid[lastAction.toY][lastAction.toX].scanned = lastAction.scanned;
                        robot.revealedTiles--;
                    }
                    
                    addLogEntry('Time reversed: Movement undone.');
                    break;
                    
                case "scan":
                    // Restore tile state
                    grid[lastAction.y][lastAction.x] = JSON.parse(JSON.stringify(lastAction.tile));
                    robot.energy = lastAction.energy;
                    robot.scannedTiles--;
                    
                    addLogEntry('Time reversed: Scan undone.');
                    break;
                    
                case "harvest":
                    // Restore resource
                    grid[lastAction.y][lastAction.x].type = lastAction.tileType;
                    grid[lastAction.y][lastAction.x].variant = lastAction.tileVariant;
                    
                    // Restore robot state
                    robot.energy = lastAction.energy;
                    robot.minerals = lastAction.minerals;
                    robot.crystals = lastAction.crystals;
                    robot.exotic = lastAction.exotic;
                    
                    addLogEntry('Time reversed: Resource harvesting undone.');
                    break;
                    
                case "build_base":
                    // Restore tile and robot state
                    grid[lastAction.y][lastAction.x].type = 'empty';
                    robot.energy = lastAction.energy;
                    robot.minerals = lastAction.minerals;
                    robot.hasBase = false;
                    robot.baseLocation = null;
                    
                    addLogEntry('Time reversed: Base construction undone.');
                    break;
                    
                case "build_ship":
                    // Restore tile and robot state
                    grid[lastAction.y][lastAction.x].type = 'base';
                    robot.energy = lastAction.energy;
                    robot.minerals = lastAction.minerals;
                    robot.crystals = lastAction.crystals;
                    robot.shipConstructed = false;
                    
                    addLogEntry('Time reversed: Ship construction undone.');
                    break;
                    
                case "teleport":
                    // Undo teleport
                    robot.x = lastAction.fromX;
                    robot.y = lastAction.fromY;
                    robot.energy = lastAction.energy;
                    
                    // Restore teleport charge
                    teleportAvailable = true;
                    
                    addLogEntry('Time reversed: Teleportation undone.');
                    break;
                    
                default:
                    addLogEntry('Unable to reverse that action.');
                    return;
            }
            
            // Used up the time reversal
            timeReversalAvailable = false;
            robot.lastAction = null;
            
            // Update UI
            drawGrid();
            updateUI();
            updateObjectiveDisplay();
            
            // Play effect
            playSoundEffect('button_click');
        }

        // Special event handling
        function showSpecialEvent(eventData) {
            // Set event details in modal
            document.getElementById('specialEventTitle').textContent = eventData.name;
            document.getElementById('specialEventContent').textContent = eventData.description;

            // Clear previous choices
            const choicesContainer = document.getElementById('specialEventChoices');
            choicesContainer.innerHTML = '';

            // Add choices
            for (let i = 0; i < eventData.choices.length; i++) {
                const choiceBtn = document.createElement('button');
                choiceBtn.textContent = eventData.choices[i].text;
                choiceBtn.className = 'big-btn';
                choiceBtn.style.margin = '0.5rem';

                // Store choice index for reference
                choiceBtn.dataset.choiceIndex = i;

                // Add click event
                choiceBtn.addEventListener('click', () => {
                    applySpecialEventChoice(eventData, i);
                });

                choicesContainer.appendChild(choiceBtn);
            }

            // Hide the close button initially
            document.getElementById('specialEventCloseBtn').style.display = 'none';

            // Show the modal
            document.getElementById('special-event-overlay').style.display = 'flex';

            // Play discovery sound
            playSoundEffect('discovery');
        }

        function applySpecialEventChoice(eventData, choiceIndex) {
            const choice = eventData.choices[choiceIndex];
            const outcome = choice.outcome;
            const effect = choice.effect;

            // Update modal to show outcome
            document.getElementById('specialEventTitle').textContent = "Outcome";
            document.getElementById('specialEventContent').textContent = outcome;
            document.getElementById('specialEventChoices').innerHTML = '';

            // Apply effect based on type
            if (effect.type === "resource") {
                for (const [resource, amount] of Object.entries(effect.value)) {
                    if (resource === "minerals") robot.minerals += amount;
                    else if (resource === "crystals") robot.crystals += amount;
                    else if (resource === "exotic") robot.exotic += amount;
                    else if (resource === "energy") {
                        robot.energy = Math.min(robot.maxEnergy, robot.energy + amount);
                    }
                }
            } else if (effect.type === "upgrade") {
                addUpgrade(effect.value);
            } else if (effect.type === "reveal_map") {
                // Reveal a percentage of the map
                const revealPercent = effect.value;
                const totalTiles = gridSize * gridSize;
                const tilesToReveal = Math.floor(totalTiles * revealPercent);

                // Get all unrevealed tiles
                const unrevealedTiles = [];
                for (let y = 0; y < gridSize; y++) {
                    for (let x = 0; x < gridSize; x++) {
                        if (!grid[y][x].revealed) {
                            unrevealedTiles.push({ x, y });
                        }
                    }
                }

                // Shuffle array
                for (let i = unrevealedTiles.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [unrevealedTiles[i], unrevealedTiles[j]] = [unrevealedTiles[j], unrevealedTiles[i]];
                }

                // Reveal tiles
                for (let i = 0; i < Math.min(tilesToReveal, unrevealedTiles.length); i++) {
                    const tile = unrevealedTiles[i];
                    revealTile(tile.x, tile.y);
                }

                drawGrid();
            } else if (effect.type === "tech_point") {
                techPoints += effect.value;
                addLogEntry(`Gained ${effect.value} tech point${effect.value > 1 ? 's' : ''}!`);
                
                // Apply secondary effect if present
                if (effect.secondary) {
                    const secondary = effect.secondary;
                    
                    if (secondary.type === "reveal_map") {
                        // Reveal the entire map
                        for (let y = 0; y < gridSize; y++) {
                            for (let x = 0; x < gridSize; x++) {
                                if (!grid[y][x].revealed) {
                                    revealTile(x, y);
                                }
                            }
                        }
                    } else if (secondary.type === "resource") {
                        for (const [resource, amount] of Object.entries(secondary.value)) {
                            if (resource === "minerals") robot.minerals += amount;
                            else if (resource === "crystals") robot.crystals += amount;
                            else if (resource === "exotic") robot.exotic += amount;
                            else if (resource === "energy") {
                                robot.energy = Math.min(robot.maxEnergy, robot.energy + amount);
                            }
                        }
                    } else if (secondary.type === "upgrade") {
                        addUpgrade(secondary.value);
                    }
                }
            } else if (effect.type === "relic") {
                // Add a random undiscovered relic
                const undiscoveredRelics = RELICS.filter(r => !r.discovered);
                if (undiscoveredRelics.length > 0) {
                    const randomIndex = Math.floor(Math.random() * undiscoveredRelics.length);
                    const relicToAdd = undiscoveredRelics[randomIndex];
                    
                    // Mark to show the relic discovery after closing this event
                    window.pendingRelicId = relicToAdd.id;
                }
            } else if (effect.type === "drone") {
                // Unlock a specific drone
                const drone = DRONES.find(d => d.id === effect.value);
                if (drone) {
                    drone.unlocked = true;
                    updateDroneDisplay();
                    
                    // Update achievement progress
                    updateAchievementProgress("fleet_admiral", 1);
                }
            } else if (effect.type === "status") {
                // Add a temporary status effect
                robot.statusEffects.push({
                    name: effect.value,
                    duration: effect.duration,
                    source: 'event'
                });
            }

            // Show close button
            document.getElementById('specialEventCloseBtn').style.display = 'block';

            // Log the choice
            addLogEntry(`Special event: ${eventData.name} - ${choice.text}`);

            // Update UI
            updateUI();
            updateGameDataDisplay();
        }

        function closeSpecialEvent() {
            document.getElementById('special-event-overlay').style.display = 'none';

            // Check if we have a pending relic to show
            if (window.pendingRelicId) {
                addRelic(window.pendingRelicId);
                window.pendingRelicId = null;
            }
            
            // Play sound effect
            playSoundEffect('button_click');
        }

        // Check side mission progress
        function checkSideMissionProgress(actionType, data = {}) {
            const completedMissions = [];

            for (let i = 0; i < activeSideMissions.length; i++) {
                const mission = activeSideMissions[i];

                if (mission.completed) continue;

                if (actionType === "scan" && mission.parameters.type === "scan") {
                    mission.parameters.current++;

                    if (mission.parameters.current >= mission.parameters.target) {
                        mission.completed = true;
                        completedMissions.push(mission);
                        surveyMissionsCompleted++;
                    }
                } else if (actionType === "collect" && mission.parameters.type === "collect") {
                    if (mission.parameters.resourceType === data.resourceType) {
                        mission.parameters.current += data.amount;

                        if (mission.parameters.current >= mission.parameters.target) {
                            mission.completed = true;
                            completedMissions.push(mission);
                        }
                    }
                } else if (actionType === "anomaly" && mission.parameters.type === "anomaly") {
                    if (data.x === mission.parameters.locationX && 
                        data.y === mission.parameters.locationY) {
                        mission.parameters.current = 1;
                        mission.completed = true;
                        completedMissions.push(mission);
                    }
                } else if (actionType === "map_reveal" && mission.parameters.type === "map_reveal") {
                    // Calculate percentage of map revealed
                    const totalTiles = gridSize * gridSize;
                    const revealedPercentage = Math.floor((robot.revealedTiles / totalTiles) * 100);
                    
                    if (revealedPercentage >= mission.parameters.target) {
                        mission.completed = true;
                        completedMissions.push(mission);
                    }
                } else if (actionType === "weather_change" && mission.parameters.type === "weather_survival") {
                    // Only increment if it's adverse weather
                    if (currentWeather && currentWeather.name !== "Clear") {
                        mission.parameters.current++;
                        
                        if (mission.parameters.current >= mission.parameters.target) {
                            mission.completed = true;
                            completedMissions.push(mission);
                        }
                    }
                }
            }

            // Handle completed missions
            for (const mission of completedMissions) {
                completeSideMission(mission);
            }

            // Update display
            updateSideMissionsDisplay();
        }

        // Complete side mission
        function completeSideMission(mission) {
            // Apply rewards
            if (mission.reward.score) {
                robot.missionScore += mission.reward.score;
                totalScore += mission.reward.score;
                addLogEntry(`Side mission completed! +${mission.reward.score} points`);
            }

            if (mission.reward.resources) {
                for (const [resource, amount] of Object.entries(mission.reward.resources)) {
                    if (resource === "minerals") robot.minerals += amount;
                    else if (resource === "crystals") robot.crystals += amount;
                    else if (resource === "exotic") robot.exotic += amount;
                    else if (resource === "energy") {
                        robot.energy = Math.min(robot.maxEnergy, robot.energy + amount);
                    }
                }

                addLogEntry('Received resources as reward!');
            }

            if (mission.reward.upgrade) {
                if (mission.reward.upgrade === "random") {
                    // Choose a random upgrade
                    const availableUpgrades = Object.keys(UPGRADES).filter(
                        id => !upgrades.includes(id)
                    );

                    if (availableUpgrades.length > 0) {
                        const randomUpgrade = availableUpgrades[
                            Math.floor(Math.random() * availableUpgrades.length)
                        ];

                        addUpgrade(randomUpgrade);
                    } else {
                        // If all upgrades already acquired, give bonus points
                        robot.missionScore += 100;
                        totalScore += 100;
                        addLogEntry('All upgrades already acquired. +100 bonus points!');
                    }
                } else {
                    addUpgrade(mission.reward.upgrade);
                }
            }
            
            if (mission.reward.techPoints) {
                techPoints += mission.reward.techPoints;
                addLogEntry(`Gained ${mission.reward.techPoints} tech point${mission.reward.techPoints > 1 ? 's' : ''}!`);
            }
            
            if (mission.reward.xp) {
                const xpGained = addExperience(mission.reward.xp);
                addLogEntry(`Gained ${xpGained} XP!`);
            }
            
            // Update achievement progress
            if (mission.parameters.type === "scan") {
                updateAchievementProgress("planetary_surveyor", 1);
            }

            // Show notification
            showNotification(`Mission completed: ${mission.name}!`);

            // Save game data
            saveGameData();
        }

        function completeMission() {
            // Make sure any active timer is cleared
            if (robot.actionTimer) {
                clearInterval(robot.actionTimer);
                robot.actionTimer = null;
            }

            // Check if special efficiency mission was completed
            if (specialMission && specialMission.parameters.type === "efficiency") {
                if (robot.energy >= specialMission.parameters.maxEnergy) {
                    // Failed the efficiency mission
                    addLogEntry('Special mission failed: Used too much energy');
                } else {
                    // Completed the efficiency mission
                    specialMission.parameters.completed = true;
                    completeSpecialMission();
                }
            }

            // Calculate stats
            const resourceTiles = grid.flat().filter(tile =>
                ['minerals', 'crystals', 'exotic'].includes(tile.type)
            ).length;

            const mineralCost = 3; // Base cost for upgrades that might have reduced it
            const crystalCost = 2;
            
            const totalInitialResources = resourceTiles + 
                (robot.shipConstructed ? (mineralCost + crystalCost) : 0) + // Account for used resources
                (robot.hasBase ? mineralCost : 0) +
                robot.minerals + robot.crystals + robot.exotic;

            const resourcesCollected = (robot.minerals + robot.crystals + robot.exotic) +
                (robot.shipConstructed ? (mineralCost + crystalCost) : 0) + // Account for used resources
                (robot.hasBase ? mineralCost : 0);

            const efficiency = Math.min(100, Math.round((resourcesCollected / Math.max(1, totalInitialResources)) * 100));

            // Calculate score
            let missionScore = robot.missionScore;

            // Add score for resources collected
            missionScore += resourcesCollected * 10;

            // Add score for efficiency
            missionScore += efficiency * 5;

            // Add score for tiles revealed
            missionScore += robot.revealedTiles * 5;

            // Add score for completing mission
            missionScore += 500;

            // Add bonus for energy remaining
            missionScore += Math.round(robot.energy) * 2;

            // Update total score
            totalScore += missionScore;
            robot.missionScore = missionScore;

            // Update exploration stats
            planetsExplored++;

            // Check for weather survival achievement
            if (currentWeather && currentWeather.name !== "Clear") {
                weatherSurvivals++;
                updateAchievementProgress("weather_withstander", 1);
            }
            
            // Calculate XP earned
            let xpEarned = 25 + Math.floor(efficiency / 10) + Math.floor(missionScore / 100);
            
            // Apply XP gain
            const gainedXP = addExperience(xpEarned);

            // Update modal with stats
            document.getElementById('modalTitle').textContent = `Mission ${missionNumber} Complete!`;
            document.getElementById('modalContent').textContent =
                `${currentPlanet.name} secured. Ship launched to continue the swarm's exploration.`;

            document.getElementById('statMission').textContent = missionNumber;
            document.getElementById('statResources').textContent = resourcesCollected;
            document.getElementById('statEfficiency').textContent = `${efficiency}%`;
            document.getElementById('statScore').textContent = missionScore;
            document.getElementById('statXP').textContent = gainedXP;

            // Check for achievements
            checkAchievements(efficiency);

            // Show mission achievements
            const achievementsContainer = document.getElementById('missionAchievements');
            achievementsContainer.innerHTML = '';

            // Show the 3 most recent unlocked achievements
            const recentAchievements = ACHIEVEMENTS.filter(a => a.unlocked)
                .slice(-3).reverse();

            if (recentAchievements.length > 0) {
                for (const achievement of recentAchievements) {
                    const badge = document.createElement('div');
                    badge.className = 'achievement-badge unlocked';
                    badge.title = achievement.name + ': ' + achievement.description;
                    badge.textContent = achievement.icon;
                    achievementsContainer.appendChild(badge);
                }
            }

            // Show mission completion modal
            document.getElementById('game-overlay').style.display = 'flex';

            // Increment mission counter
            missionNumber++;

            // Save game data
            saveGameData();
        }

        // Check for unlocked achievements
        function checkAchievements(efficiency) {
            const unlockedAchievements = [];

            // First Steps - Complete first mission
            if (!ACHIEVEMENTS[0].unlocked && planetsExplored === 1) {
                ACHIEVEMENTS[0].unlocked = true;
                unlockedAchievements.push(ACHIEVEMENTS[0]);
            }

            // Resource Collector - 50 total resources
            if (!ACHIEVEMENTS[1].unlocked && totalResources >= 50) {
                ACHIEVEMENTS[1].unlocked = true;
                unlockedAchievements.push(ACHIEVEMENTS[1]);
            }

            // Efficient Explorer - 80% efficiency
            if (!ACHIEVEMENTS[2].unlocked && efficiency >= 80) {
                ACHIEVEMENTS[2].unlocked = true;
                unlockedAchievements.push(ACHIEVEMENTS[2]);
            }
            
            // Centurion - Total score of 10,000
            if (!ACHIEVEMENTS.find(a => a.id === "centurion").unlocked && totalScore >= 10000) {
                const achievement = ACHIEVEMENTS.find(a => a.id === "centurion");
                achievement.unlocked = true;
                unlockedAchievements.push(achievement);
            }
            
            // Planetary Network - Explore 20 planets
            if (!ACHIEVEMENTS.find(a => a.id === "planetary_network").unlocked && planetsExplored >= 20) {
                const achievement = ACHIEVEMENTS.find(a => a.id === "planetary_network");
                achievement.unlocked = true;
                unlockedAchievements.push(achievement);
            }

            // Show achievement notifications after mission
            if (unlockedAchievements.length > 0) {
                // Add achievement bonus to score
                for (const achievement of unlockedAchievements) {
                    totalScore += achievement.bonus;

                    // Schedule achievement notification for after mission completion
                    setTimeout(() => {
                        showAchievementNotification(achievement);
                    }, 1000);
                }
            }
        }

        // Show achievement notification
        function showAchievementNotification(achievement) {
            document.getElementById('achievementName').textContent = achievement.name;
            document.getElementById('achievementDescription').textContent = achievement.description;
            document.getElementById('achievementBonus').textContent = '+' + achievement.bonus;

            document.getElementById('achievement-overlay').style.display = 'flex';

            // Play achievement sound
            playSoundEffect('achievement');
        }

        // Close achievement notification
        function closeAchievementNotification() {
            document.getElementById('achievement-overlay').style.display = 'none';

            // Play sound effect
            playSoundEffect('button_click');
        }

        function startNextMission() {
            // Hide mission completion modal
            document.getElementById('game-overlay').style.display = 'none';

            // Start a new mission
            startNewMission();

            // Make sure game is active
            gameActive = true;

            addLogEntry('New planet detected! Continuing the swarm exploration...');

            // Play sound effect
            playSoundEffect('button_click');
        }

        function startGame() {
            gameActive = true;
            document.getElementById('start-game-overlay').style.display = 'none';
            addLogEntry('Mission started! Initiating planet scan...');

            // Clear existing timers if they exist
            if (energyDrainTimer) clearInterval(energyDrainTimer);
            if (animationTimer) clearInterval(animationTimer);

            // Set up energy drain timer
            energyDrainTimer = setInterval(() => {
                if (gameActive && !robot.busy && robot.energy > 0) {
                    // Apply weather effects to energy drain
                    let drainRate = 0.1;
                    if (currentWeather && currentWeather.effect && 
                        currentWeather.effect.type === "energy_drain") {
                        drainRate *= currentWeather.effect.value;
                    }

                    // Apply passive energy regeneration from relics
                    drainRate -= robot.passive_energy_regen;
                    
                    // Energy drain can't go negative (would be energy gain)
                    drainRate = Math.max(0, drainRate);

                    robot.energy = Math.max(0, robot.energy - drainRate);
                    
                    // Apply energy regeneration if drain became zero
                    if (drainRate === 0 && robot.passive_energy_regen > 0) {
                        robot.energy = Math.min(robot.maxEnergy, robot.energy + robot.passive_energy_regen);
                    }
                    
                    updateUI();

                    // Check for game over condition
                    if (robot.energy <= 0) {
                        gameOver();
                    }
                }
            }, 1000);
            
            // Set up cooldown timer for drones
            const droneTimer = setInterval(() => {
                if (gameActive) {
                    let updated = false;
                    
                    // Reduce cooldown for all deployed drones
                    for (const drone of deployedDrones) {
                        if (drone.cooldownRemaining > 0) {
                            drone.cooldownRemaining--;
                            updated = true;
                        }
                    }
                    
                    if (updated) {
                        updateDroneDisplay();
                    }
                }
            }, 5000); // Check drone cooldowns every 5 seconds

            // Play background music
            playBackgroundMusic();

            // Play sound effect
            playSoundEffect('button_click');
        }

        // New function for starting actions with real-time implementation
        function startAction(completionFunction) {
            robot.actionCompletionFunction = completionFunction;
            robot.actionMaxTime = robot.actionTimeRemaining;
            robot.actionProgress = 0;

            addLogEntry(`Starting ${robot.currentAction}: ${robot.actionTimeRemaining.toFixed(1)} seconds`);
            updateUI();

            // Clear any existing timer
            if (robot.actionTimer) {
                clearInterval(robot.actionTimer);
            }

            // Start a timer that updates every 100ms
            robot.actionTimer = setInterval(() => {
                robot.actionProgress += 0.1;

                // Update UI to show progress
                updateUI();

                // Check if action is complete
                if (robot.actionProgress >= robot.actionMaxTime) {
                    clearInterval(robot.actionTimer);
                    robot.busy = false;
                    robot.currentAction = null;

                    // Execute the completion function
                    if (robot.actionCompletionFunction) {
                        robot.actionCompletionFunction();
                        robot.actionCompletionFunction = null;
                    }

                    updateUI();
                }
            }, 100);
        }

        // UI and Utility Functions
        function updateUI() {
            // Update energy bar and text
            document.getElementById('energy').textContent = Math.floor(robot.energy);
            const energyPercent = (robot.energy / robot.maxEnergy) * 100;
            const energyBar = document.getElementById('energyBar');
            energyBar.style.width = `${energyPercent}%`;

            // Change energy bar color based on level
            if (energyPercent < 25) {
                energyBar.style.background = 'linear-gradient(90deg, #f93, #f93)';
            } else if (energyPercent < 50) {
                energyBar.style.background = 'linear-gradient(90deg, #f93, #fd3)';
            } else {
                energyBar.style.background = 'linear-gradient(90deg, #f93, #fd3, #4af)';
            }

            // Update other resources
            document.getElementById('minerals').textContent = robot.minerals;
            document.getElementById('crystals').textContent = robot.crystals;
            document.getElementById('exotic').textContent = robot.exotic;

            // Update action timer
            const actionProgressContainer = document.getElementById('actionProgressContainer');
            const actionProgressBar = document.getElementById('actionProgressBar');

            if (robot.busy) {
                document.getElementById('actionTimer').textContent =
                    `${robot.currentAction}`;

                // Show and update progress bar
                actionProgressContainer.style.display = 'block';
                const progressPercent = (robot.actionProgress / robot.actionMaxTime) * 100;
                actionProgressBar.style.width = `${progressPercent}%`;
            } else {
                document.getElementById('actionTimer').textContent = 'Ready';
                actionProgressContainer.style.display = 'none';
            }

            // Update status effects display
            const statusEffectsElement = document.getElementById('statusEffects');
            statusEffectsElement.innerHTML = '';

            robot.statusEffects.forEach(effect => {
                const effectElement = document.createElement('div');
                effectElement.className = 'status-effect';
                effectElement.textContent = `${effect.name} (${effect.duration})`;
                if (currentWeather && effect.source === 'weather') {
                    effectElement.title = currentWeather.description;
                }
                statusEffectsElement.appendChild(effectElement);
            });

            // Update button states based on current game state
            updateButtonStates();

            // Update score display
            document.getElementById('totalScore').textContent = totalScore;
        }

        function updateButtonStates() {
            const scanBtn = document.getElementById('scanBtn');
            const buildBaseBtn = document.getElementById('buildBaseBtn');
            const harvestBtn = document.getElementById('harvestBtn');
            const constructShipBtn = document.getElementById('constructShipBtn');

            // Movement buttons
            const moveUpBtn = document.getElementById('moveUpBtn');
            const moveDownBtn = document.getElementById('moveDownBtn');
            const moveLeftBtn = document.getElementById('moveLeftBtn');
            const moveRightBtn = document.getElementById('moveRightBtn');

            // If game not active or robot is busy, disable all action buttons
            if (!gameActive || robot.busy) {
                scanBtn.disabled = true;
                buildBaseBtn.disabled = true;
                harvestBtn.disabled = true;
                constructShipBtn.disabled = true;
                moveUpBtn.disabled = true;
                moveDownBtn.disabled = true;
                moveLeftBtn.disabled = true;
                moveRightBtn.disabled = true;
                return;
            }

            // Base energy costs
            let scanEnergyCost = 3;
            let moveEnergyCost = 3;
            let harvestEnergyCost = 5;

            // Apply upgrades
            scanEnergyCost *= getUpgradeEffect("efficiency", "energy");
            moveEnergyCost *= getUpgradeEffect("efficiency", "movement");
            harvestEnergyCost *= getUpgradeEffect("efficiency", "energy");

            // Apply weather effects
            if (currentWeather && currentWeather.effect) {
                if (currentWeather.effect.type === "scan_penalty") {
                    scanEnergyCost /= currentWeather.effect.value; // Higher cost
                } else if (currentWeather.effect.type === "harvest_penalty") {
                    harvestEnergyCost /= currentWeather.effect.value; // Higher cost
                } else if (currentWeather.effect.type === "energy_drain") {
                    // This is applied in the energy drain timer
                }
            }

            // Round costs to whole numbers for display
            scanEnergyCost = Math.round(scanEnergyCost);
            moveEnergyCost = Math.round(moveEnergyCost);
            harvestEnergyCost = Math.round(harvestEnergyCost);

            // Update button text with costs
            scanBtn.textContent = `Scan Tile (‚ö°${scanEnergyCost})`;
            harvestBtn.textContent = `Harvest (‚ö°${harvestEnergyCost})`;

            // Scan button
            scanBtn.disabled = robot.energy < scanEnergyCost ||
                grid[robot.y][robot.x].revealed;
                
            // Get mineral cost for base
            let mineralCost = 3;
            const mineralTech = TECH_TREE.find(t => t.id === "mineral_processing" && t.unlocked);
            if (mineralTech) {
                const costEffect = mineralTech.effects.find(e => e.type === "reduced_cost" && e.target === "base");
                if (costEffect) {
                    mineralCost = costEffect.value;
                }
            }
            
            // Check for side mission that requires efficient construction
            const efficientMission = activeSideMissions.find(
                m => m.parameters.type === "efficient_construction" && !m.completed
            );
            
            if (efficientMission) {
                mineralCost = efficientMission.parameters.target;
            }

            // Build base button
            buildBaseBtn.disabled = robot.minerals < mineralCost ||
                robot.hasBase ||
                !grid[robot.y][robot.x].revealed ||
                grid[robot.y][robot.x].type !== 'empty';
                
            // Update button text with cost
            buildBaseBtn.textContent = `Build Base (üî∑${mineralCost})`;
            
            // Get ship costs
            let shipMineralCost = 5;
            let shipCrystalCost = 2;
            
            // Apply tech tree reductions
            const crystalTech = TECH_TREE.find(t => t.id === "crystal_harmonics" && t.unlocked);
            if (crystalTech) {
                const costEffect = crystalTech.effects.find(e => e.type === "reduced_cost" && e.target === "ship");
                if (costEffect) {
                    shipCrystalCost = costEffect.value;
                }
            }
            
            // Update ship button text
            constructShipBtn.textContent = `Launch Ship (üî∑${shipMineralCost}, üíé${shipCrystalCost})`;

            // Harvest button
            harvestBtn.disabled = robot.energy < harvestEnergyCost ||
                !grid[robot.y][robot.x].revealed ||
                !['minerals', 'crystals', 'exotic'].includes(grid[robot.y][robot.x].type);

            // Construct ship button
            constructShipBtn.disabled = !robot.hasBase ||
                robot.minerals < shipMineralCost ||
                robot.crystals < shipCrystalCost ||
                robot.x !== robot.baseLocation.x ||
                robot.y !== robot.baseLocation.y;

            // Movement buttons - support diagonal movement if enabled
            // Check if we can move in each direction and if the tile is not an obstacle
            const canMoveUp = robot.y > 0 && robot.energy >= moveEnergyCost &&
                (!grid[robot.y - 1][robot.x].revealed || grid[robot.y - 1][robot.x].type !== 'obstacle');
                
            const canMoveDown = robot.y < gridSize - 1 && robot.energy >= moveEnergyCost &&
                (!grid[robot.y + 1][robot.x].revealed || grid[robot.y + 1][robot.x].type !== 'obstacle');
                
            const canMoveLeft = robot.x > 0 && robot.energy >= moveEnergyCost &&
                (!grid[robot.y][robot.x - 1].revealed || grid[robot.y][robot.x - 1].type !== 'obstacle');
                
            const canMoveRight = robot.x < gridSize - 1 && robot.energy >= moveEnergyCost &&
                (!grid[robot.y][robot.x + 1].revealed || grid[robot.y][robot.x + 1].type !== 'obstacle');
                
            moveUpBtn.disabled = !canMoveUp;
            moveDownBtn.disabled = !canMoveDown;
            moveLeftBtn.disabled = !canMoveLeft;
            moveRightBtn.disabled = !canMoveRight;
            
            // If diagonal movement is enabled, show diagonal movement buttons
            if (diagonalMovementEnabled) {
                // Add diagonal movement buttons if not already added
                const movementPanel = document.querySelector('.movement-panel');
                
                if (!document.getElementById('moveUpLeftBtn')) {
                    // Clear existing buttons
                    movementPanel.innerHTML = '';
                    
                    // Add diagonal movement buttons
                    movementPanel.innerHTML = `
                        <button id="moveUpLeftBtn" onclick="moveRobot('up-left')">‚Üñ</button>
                        <button id="moveUpBtn" onclick="moveRobot('up')">‚Üë</button>
                        <button id="moveUpRightBtn" onclick="moveRobot('up-right')">‚Üó</button>
                        <button id="moveLeftBtn" onclick="moveRobot('left')">‚Üê</button>
                        <button disabled>‚óè</button>
                        <button id="moveRightBtn" onclick="moveRobot('right')">‚Üí</button>
                        <button id="moveDownLeftBtn" onclick="moveRobot('down-left')">‚Üô</button>
                        <button id="moveDownBtn" onclick="moveRobot('down')">‚Üì</button>
                        <button id="moveDownRightBtn" onclick="moveRobot('down-right')">‚Üò</button>
                    `;
                }
                
                // Enable/disable diagonal movement buttons
                const canMoveUpLeft = canMoveUp && canMoveLeft;
                const canMoveUpRight = canMoveUp && canMoveRight;
                const canMoveDownLeft = canMoveDown && canMoveLeft;
                const canMoveDownRight = canMoveDown && canMoveRight;
                
                document.getElementById('moveUpLeftBtn').disabled = !canMoveUpLeft;
                document.getElementById('moveUpRightBtn').disabled = !canMoveUpRight;
                document.getElementById('moveDownLeftBtn').disabled = !canMoveDownLeft;
                document.getElementById('moveDownRightBtn').disabled = !canMoveDownRight;
            }
        }

        function updateObjectiveDisplay() {
            const objectiveProgressElement = document.getElementById('objectiveProgress');
            const objectiveStatusElement = document.getElementById('objectiveStatus');
            let progress = 0;
            let statusText = '';

            if (robot.shipConstructed) {
                progress = 100;
                statusText = 'Complete! Ship ready for launch!';
            } else if (robot.hasBase) {
                progress = 50 + Math.min(50, (robot.minerals / 5 * 25) + (robot.crystals / 2 * 25));
                statusText = `In Progress - ${Math.round(progress)}%`;
            } else {
                progress = Math.min(50, robot.minerals / 3 * 50);
                statusText = `In Progress - ${Math.round(progress)}%`;
            }

            objectiveProgressElement.value = progress;
            objectiveStatusElement.textContent = statusText;

            // Update special mission display
            updateSpecialMissionDisplay();
            
            // Update map reveal mission progress
            for (const mission of activeSideMissions) {
                if (mission.parameters.type === "map_reveal") {
                    const totalTiles = gridSize * gridSize;
                    const revealedPercentage = Math.floor((robot.revealedTiles / totalTiles) * 100);
                    
                    // Update the mission text
                    if (!mission.completed) {
                        const missionElements = document.querySelectorAll('.side-mission');
                        for (const element of missionElements) {
                            if (element.textContent.includes(mission.name)) {
                                element.textContent = `${mission.name}: ${revealedPercentage}%/${mission.parameters.target}% ${mission.description}`;
                                break;
                            }
                        }
                    }
                }
            }
        }

        function addLogEntry(message, isImportant = false) {
            const missionLog = document.getElementById('missionLog');
            const entry = document.createElement('div');
            entry.className = 'log-entry';

            if (isImportant) {
                entry.classList.add('important');
            }

            // Use timestamp
            const timestamp = new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', second: '2-digit' });
            entry.textContent = `[${timestamp}] ${message}`;

            missionLog.appendChild(entry);
            missionLog.scrollTop = missionLog.scrollHeight;
        }

        function createTooltip() {
            tooltipElement = document.createElement('div');
            tooltipElement.className = 'tooltip';
            tooltipElement.style.display = 'none';
            document.body.appendChild(tooltipElement);
        }

        function showTooltip(x, y, text) {
            tooltipElement.textContent = text;
            tooltipElement.style.left = `${x + 10}px`;
            tooltipElement.style.top = `${y + 10}px`;
            tooltipElement.style.display = 'block';
        }

        function hideTooltip() {
            tooltipElement.style.display = 'none';
        }

        function handleMouseMove(event) {
            const rect = canvas.getBoundingClientRect();
            const mouseX = event.clientX - rect.left;
            const mouseY = event.clientY - rect.top;

            handleTooltipMovement(mouseX, mouseY);
        }

        function handleTooltipMovement(x, y) {
            const tileX = Math.floor(x / tileSize);
            const tileY = Math.floor(y / tileSize);

            if (tileX >= 0 && tileX < gridSize && tileY >= 0 && tileY < gridSize) {
                const tile = grid[tileY][tileX];
                let tooltipText = '';

                if (tile.revealed) {
                    switch (tile.type) {
                        case 'empty':
                            tooltipText = 'Empty terrain';
                            break;
                        case 'minerals':
                            tooltipText = 'Mineral deposit';
                            break;
                        case 'crystals':
                            tooltipText = 'Crystal formation';
                            break;
                        case 'exotic':
                            tooltipText = 'Exotic material';
                            break;
                        case 'energy':
                            tooltipText = 'Energy source';
                            break;
                        case 'obstacle':
                            tooltipText = 'Impassable terrain';
                            // Check if terraforming tech is unlocked
                            const terraformTech = TECH_TREE.find(t => t.id === "planetary_terraforming" && t.unlocked);
                            if (terraformTech) {
                                const obstacleEffect = terraformTech.effects.find(e => e.type === "obstacle_conversion");
                                if (obstacleEffect && obstacleEffect.value === true) {
                                    tooltipText += ' (Can terraform)';
                                }
                            }
                            break;
                        case 'base':
                            tooltipText = 'Your base of operations';
                            break;
                        case 'ship':
                            tooltipText = 'Ship ready for launch';
                            break;
                    }

                    // Add anomaly text
                    if (tile.isAnomaly) {
                        tooltipText += ' - Unusual readings detected';
                    }
                    
                    // Add relic text
                    if (tile.isRelic) {
                        tooltipText += ' - Ancient artifact detected';
                    }
                    
                    // Add special mission markers
                    if (specialMission) {
                        if (specialMission.parameters.type === "investigate" &&
                            specialMission.parameters.target.x === tileX &&
                            specialMission.parameters.target.y === tileY) {
                            tooltipText += ' - Signal source location';
                        }
                        
                        if (specialMission.parameters.type === "collect_cache" &&
                            specialMission.parameters.target.x === tileX &&
                            specialMission.parameters.target.y === tileY) {
                            tooltipText += ' - Resource cache location';
                        }
                        
                        if (specialMission.parameters.type === "access_archive" &&
                            specialMission.parameters.target.x === tileX &&
                            specialMission.parameters.target.y === tileY) {
                            tooltipText += ' - Ancient archive location';
                        }
                        
                        if (specialMission.parameters.type === "stabilize_points") {
                            // Check all target points
                            for (let i = 0; i < specialMission.parameters.targets.length; i++) {
                                const target = specialMission.parameters.targets[i];
                                if (target.x === tileX && target.y === tileY) {
                                    if (i < specialMission.parameters.currentTarget) {
                                        tooltipText += ' - Stabilized quantum point';
                                    } else {
                                        tooltipText += ' - Unstable quantum point';
                                    }
                                    break;
                                }
                            }
                        }
                    }
                    
                    // Add coordinates
                    tooltipText += ` (${tileX},${tileY})`;
                } else if (tile.scanned) {
                    tooltipText = 'Scanned - Move here to reveal';
                    
                    // Add hint if it's an anomaly or relic
                    if (tile.isAnomaly) {
                        tooltipText += ' - Unusual readings detected';
                    }
                    
                    if (tile.isRelic) {
                        tooltipText += ' - Ancient artifact detected';
                    }
                } else {
                    tooltipText = 'Unexplored terrain';
                }

                const clientX = x + canvas.getBoundingClientRect().left;
                const clientY = y + canvas.getBoundingClientRect().top;
                showTooltip(clientX, clientY, tooltipText);
            } else {
                hideTooltip();
            }
        }
    </script>
</body>
</html>